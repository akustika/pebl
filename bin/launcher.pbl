#!/usr/bin/env pebl
##  This is a PEBL script that acts as a cross-platform 
##  launcher for PEBL.
## Version 0.3: Adds parameter setting (version 0.14), 
## data file combining, http version check.  
##
##  Version 0.2: Initial release, to accompany PEBL 0.13.
##  (c) 2011-2014 Shane T. Mueller, Ph.D. smueller@obereed.net
##

define Start(p)
{

    gdebug <- 0
	gUseReloc <-  1  ##Set this from 0 to 1 if you want to run on windows 
                   ## NOT from an installation in Program Files, but from
                   ##A PEBL subdirectory of the current working directory.
 
	  if(gDebug)
	  {
	   gWin <- MakeWindow()
   
	   gMessage <- EasyLabel("Started",200,200,gWin,12)
      Draw()
	  WaitForANyKeyPress()
	  }
   gsystemType <- GetSystemType()
    ghome <- GetHomeDirectory()
	
	parPairs <- [["checkfornew",1],
                 ["newest","0.14"]
                 ]
    gParams  <- CreateParameters(parpairs,"launcher.pbl.par")
	
    if (gUseReloc)
	    {
		gPEBLDIR <- "PEBL"
    	gDest <- ".\" ##was ghome. 
        gHome <- ""

		   FileSelect(["default"]) ##Giving an argument here will specify a data file
		} else {
	
     if(Length(p)>0)
	  {
  	    gPEBLDir  <- First(p)
	  } else {
        gPEBLDir <- GetWorkingDirectory()+"\..\"
	  }
	  # gPEBLDir <- GetWorkingDirectory()+"\..\"
	  # gPEBLDir <- ""
	  
	  if(gDebug)
	  {
        gMessage.text <- gPEBLDir
	    Draw()
	    WaitForANyKeyPress()
	  }
	  

	if(gSystemtype == "WINDOWS")
	   {
 	    if(FileExists(ghome+"\Documents"))
	    {
		   doc <- "\Documents"    ##win7 or later?
		} elseif (FileExists(ghome+"\My Documents"))
		{
		   ##winxp or earlier?
		   doc <- "\My Documents"
		} else {
		
		    #We should allow user-selected here, but it will take  a little care to do right.
		    SignalFatalError("Unable to locate My Documents or Documents folder")
		}
		
        } else {
	     #On linux/osx
             doc <- "/Documents"
	}

      gDest <- ghome+ doc + "/pebl-exp.0.14" 
      Print("starting in " + gDest)

	 
     ##Decide whether to run for the first time
	  if(FileExists(gdest))
	   {
	     list <- GetDirectoryListing(gdest)
             #Print(list)
	      if(Length(list)>2)
		 {
              SetWorkingDirectory(gdest)
   	          FileSelect(["default"]) ##Giving an argument here will specify a data file
                 } else{
                  RunFirstTime(p)
		 }
            } else {

	       Print("Running for the first time")
	       RunFirstTime(p)
	  }
  }
}


define FileSelect(p)
{
  
 ##Set this from 1 to 0 to turn off automatic subject code incrementation
 ##it increments the previous code by one, to avoid overwriting
 gAutoSubCode <- 1

 gLastUpdate <- GetTime() ##keep track of updates

 gScreenresInitial <- GetCurrentScreenResolution()

###set the configuration/chain name: use 'default' as default.
  if(Length(p) >0)
   {
       gConfigName <- First(p)
	   if(gConfigName==0)
        {
           gConfigName <- "default"
        }
   }else{
       gConfigName <- "default"
   }




  ## todo: 
  ## concatenate data files
  ## open battery.txt file

  ##This allows you to open up the description file directly.
  gEditDescription <- 0

  systemType <- GetSystemType()

   gFilters <- ["*.pbl" , "data files","*.*"]

  if(systemType == "LINUX") 
   {

    gViewerCommand <- "gedit"
    gPEBLName      <- "pebl"
    gOpenManual    <- "acroread /usr/local/share/pebl/doc/PEBLManual0.14.pdf&"
    gOpenURL        <- "firefox"
    gManualLoc      <- "/usr/local/share/pebl/doc/PEBLManual0.14.pdf"

		
   }elseif(systemType=="WINDOWS")   {
     
	 
	 	  ##Debugging:
      #SystemCall("echo " + gQuote+ gPEBLDir+gQuote +" & pause","")
	  #SystemCall("dir "+gQuote+"%ProgramFiles%\PEBL\bin\pebl.exe"+gQuote +"&pause","")
      #SystemCall("dir "+gQuote+"%ProgramFiles(x86)%\PEBL\bin\pebl.exe"+gQuote+"&pause","")
	
	 ##There should be a built-in that does this.
	Print(gPeblDir+"\bin\pebl.exe")
	Print(GetDirectoryListing(".\"))
	if (not FileExists(gPEBLDir+"\bin\pebl.exe"))
	 	     {
			 Print("RENAMING")
			  if(FileExists(gQuote+"%ProgramFiles%\PEBL\bin\pebl.exe"+gQuote))
			  {
		       gPEBLDir <- "%ProgramFiles%\PEBL"
			   } elseif(FileExists(gQuote+"%ProgramFiles(x86)%\PEBL\bin\pebl.exe"+gQuote))
			   {
			     gPEBLDir <- gQuote+"%ProgramFiles(x86)%\PEBL"+ gQuote
			   } else {
			      if(gDebug)
				   {
                     MessageBox("Unable to fine PEBL Base Directory.  Please hard-code",gWin)
                   }
				    gPEBLDir <- "%ProgramFiles%\PEBL"
                   #SignalFatalError("Unable to find PEBL Base Directory.")
				}
			}
    
     gViewerCommand <- "c:\windows\notepad.exe"  ##used as a backup
#     gPEBLName      <- "c:\Progra~1\PEBL\bin\pebl.exe "
     gPEBLName     <- gQuote+gPEBLDir+"\bin\pebl.exe"+gQuote+ " "
     gOpenManual    <- ""
     gManualLoc     <-  gQuote+gPEBLDir+"\doc\PEBLManual0.14.pdf"+gQuote
     ##This shouldn't be hard-coded; but for now, change to localize.
#     gManualLoc    <- "C:\Program Files\PEBL\doc\PEBLManual0.14.pdf"
     gOpenURL       <- ""

 if(gDebug)
	  {
	     MessageBox("pebl.exe:" + gPEBLName,gWin)
	   }

   }elseif(systemType == "OSX")
   {
     gViewerCommand <- "open"
     gPEBLName      <- "/opt/local/bin/pebl"
     gOpenManual    <- "acroread /opt/local/share/pebl/doc/PEBLManual0.14.pdf"
   }

   gSleepEasy <- 1


   ReadConfigFile(gConfigname)



   if(gScreenSize =="large")
   {
     gVideoWidth <- 1000
     gVideoheight <- 700
   }elseif(gScreenSize=="small")
   {
     gVideoWidth <- 1000
     gVideoheight <- 600
   }

   win <- MakeWindow("grey90")
           	   
		   
   ##make a dummy object INSIDE() will recognize as a click on the window.
   gWinDummy <- MakeCustomObject("dummy")
   gWinDummy.name <- "<CUSTOMOBJECT>"
   gWinDummy.x <- gVideoWidth/2
   gWinDummy.y <- gvideoHeight/2
   gWinDummy.width <- gVideoWidth
   gWinDummy.height <- gVideoheight

  ##Now, determine the proper translation strings.
  GetStrings(gLanguage)

  if(gFullscreen)
    {
      fstext  <- "X"
    } else { 
      fstext <- ""
    }

   ##keep track of the gOffset/select pairs when you move to new directories.
   selectStack <- []
   gselected <-1     #Which item is selected in the fileview
   gOffset <- 0      #gOffset in the fileview



   logFile <- FileOpenAppend("PEBLLaunch-log.txt")


   ##This controls the size of the file window.
   width <- 200
   if(gScreenSize=="small")
   {
     height <- 400
   }else{
     height <- 500
   }

   gutter <- 10   

   xbase <- 10
   ybase <- 100
   gYbase <- ybase
   gDirchain <- ["."]  ##this is a history of the directories you have 
                      ##navigated to.



   fontsize <- 11
   font <- MakeFont(gPEBLBaseFont,0,fontsize,MakeColor("black"),MakeColor("white"),1)

   gfilelist <- FilterDir(GetDirectoryListing(DirlistToText(gDirChain)),gDirChain,First(gFilters))
   gFlatfilelist <- Flatten(gfilelist)
   

   if(gScreenSize=="small")
   {
     adjust <- 100
   }else{
     adjust <- 0
   }
 
   run     <- MakeButton(gRuntext,xbase+100,ybase-61,win,200) 


   edit       <- MakeButton(gOpenText,xbase+55,ybase+height+20,win,120)
   combinedata <- MakeButton(gCombineDataText,xbase+55,ybase+height+45,win,120)
   exit       <- MakeButton(gExitText,xbase+55,ybase+height+70,win,120)

   viewoutput <- MakeButton(gViewDebugText,xbase+200,ybase+height+20,win,150)
   viewerror  <- MakeButton(gViewErrorText,xbase+200,ybase+height+45,win,150)


   addtochain <- MakeButton(gAddToChainText,xbase+300,ybase+height+20-100,win,120)
   clearchain <- MakeButton(gClearChainText,xbase+300,ybase+height+41-100,win,120)
   savechain <- MakeButton(gSaveChainText,xbase+430,ybase+height+41-100,win,120)
   loadchain <- MakeButton(gLoadChainText,xbase+430,ybase+height+20-100,win,120)

   yheight <- 14
   randomizeChainBox <-  MakeCheckBox(gRandomizeChainText,xbase+240,ybase+height+60-100,win,170)
   SetCheckBox(randomizechainBox,gRandomizeChain)

   ##upper right buttons
   openmanual <- MakeButton(gOpenManualText,630,50,win,130)
   about      <- MakeButton(gAboutLabelText,770,50,win,130)
   launchsize  <- MakeButton(gSizeText+gScreenSize,630,75,win,130)
   visitweb <- MakeButton(gWebText,770,75,win,130)
   wiki     <- MakeButton(gWikiText,910,50,win,130)


   donate <- MakeButton("Donate",910,75,win,130)
   review   <- MakeButton("Review PEBL",630,100,win,130)

   ##################################################
   ##  
   ##  graphical widgets related to the chain launcher.

   ##chain-launcher
   chaintitle <- EasyLabel(gExpChainText+gConfigName,xbase+210+150,290,win,18)
   chainlist <- EasyTextBox("",xbase+210,300,win,fontsize,300,200-adjust)
   chainlist.linewrap <- 0
   chainlist.text <- MakeExpChainText(gexpchain)


   launchchain <- MakeButton(gLaunchChainText,chaintitle.x,chaintitle.y-20,win,200)

   wd   <- EasyLabel(GetWorkingDirectory(),(xbase+width/2), ybase-25, win,fontsize)
   path <- EasyLabel(DirListToText(gDirChain),(xbase+width/2), ybase-10, win,fontsize)
   MoveCorner(wd,xbase,ybase-30)
   yheight <- path.height
   gYHeight <- yHeight

#   gPortalnum <- Floor((bg.height-gutter*4)/yheight)
   portalheight <- (500-adjust)


  dirlist <- DirToText(First(gfilelist),Second(gfilelist),   
                             gOffset,gDirChain)

  Print(portalheight)			   
  gPortal <- MakeScrollbox(dirlist,"File listing",
                             xbase,ybase,
			     win,fontsize,
			     width, portalheight,1)
#  DrawScrollbox(gPortal)


   description <- MakeTextBox(gNoDesc,font,420,240-adjust)
   AddObject(description,win)
   Move(description,570,115)

   title <- EasyLabel(gPEBLTitle+ GetPEBLVersion(),gVideoWidth/2,20,win,30)

   screenshotbase <- Rectangle(780,530-adjust,420,320,MakeColor("black"),1)
   screenshotdummy <- Rectangle(780,530-adjust,400,300,MakeColor("white"),1)
   AddObject(screenshotbase,win)
   AddObject(screenshotdummy,win)
   screenshot <- screenshotdummy





   subjectbox <- EasyTextBox(gsubcode,xbase+width+150,ybase,win,fontsize,60,yheight)
   sublabel   <- EasyLabel(gPartCode, xbase+width+70,subjectbox.y+subjectbox.height/2,win,fontsize)
   MoveCorner(sublabel,subjectbox.x-sublabel.width-10,subjectbox.y)
   subboxhighlight <- Rectangle(subjectbox.x+subjectbox.width/2,subjectbox.y+subjectbox.height/2,subjectbox.width,subjectbox.height,MakeColor("red"),0)
   AddObject(subboxhighlight,win)
   Hide(subboxhighlight)

   subplusbutton <-  MakeButton("+",subjectbox.x+subjectbox.width+20,subjectbox.y+5,win,20)

   filter    <- MakeButton("*.pbl",xbase+95,ybase+height-11,win,172)

###Experimenter code box:
   expbox <- EasyTextBox(gexperimenter,xbase+width+150,ybase+40,win,fontsize,60,yheight)
   explabel   <- EasyLabel(gExperCode, expbox.x,expbox.y,win,fontsize)
   MoveCorner(explabel,expbox.x-explabel.width-10,expbox.y)
   expboxhighlight <- Rectangle(expbox.x+expbox.width/2,expbox.y+expbox.height/2,expbox.width,expbox.height,MakeColor("red"),0)
   AddObject(expboxhighlight,win)
   Hide(expboxhighlight)


### Language box:
   langbox <- EasyTextBox(glanguage,xbase+width+150,ybase+80,win,fontsize,60,yheight)
   langlabel   <- EasyLabel(gLangCode, langbox.x,langbox.y,win,fontsize)
   MoveCorner(langlabel,langbox.x-langlabel.width-10,langbox.y)
   langboxhighlight <- Rectangle(langbox.x+langbox.width/2,langbox.y+langbox.height/2,langbox.width,langbox.height,MakeColor("red"),0)
   AddObject(langboxhighlight,win)
   Hide(langboxhighlight)


###Command-line options:
   clobox <- EasyTextBox(gCommandLineText,langbox.x,langbox.y+20,win,fontsize,200,yheight)
   clolabel   <- EasyLabel(gCommandLineOptions, expbox.x,expbox.y,win,fontsize)
   MoveCorner(clolabel,clobox.x-clolabel.width-10,clobox.y)
   cloboxhighlight <- Rectangle(clobox.x+clobox.width/2,clobox.y+clobox.height/2,clobox.width,clobox.height,MakeColor("red"),0)
   AddObject(cloboxhighlight,win)
   Hide(cloboxhighlight)


### parameter set pulldown:

   psetlabel   <- EasyLabel(	gParameterLabel, expbox.x,expbox.y+20,win,fontsize)
   psetbox <- MakePulldown(["default"],langbox.x,langbox.y+40,win,fontsize,200,1)
   MoveCorner(psetlabel,psetbox.x-psetlabel.width-10,psetbox.y)   


   params     <- MakeButton(gEditParams,psetlabel.x-psetlabel.width/2-30,psetlabel.y,win,50)
### screen resolution

  screenselection <- MakePulldown([gScreenRes],expbox.x,expbox.y+expbox.height+5,win,fontsize,150,1)
  gCustomScreenRes <- ""
  ##initially, use 'default'
  UpdateScreenResPulldown(screenselection)

  screenselection.selected <- Length(screenselection.list)-1
  DrawPulldown(screenselection)



  screenlabel <- EasyLabel(gScreenResLabel,expbox.x,expbox.y+20,win,fontsize)
  Move(screenlabel,screenselection.x-screenlabel.width/2-10,screenselection.y+screenlabel.height/2)

#####################################
   ##Fullscreen checkbox:
  fullscreenbox <-  MakeCheckBox(gFulltext,xbase+width+5,ybase+140,win,120)



   ##Demographics checkbox:
   demobox <-  MakeCheckBox(gCollectDemoText,xbase+width+145,ybase+140,win,200)
   SetCheckBox(demobox,gNIMHdemographics)

   gPortal.list <- DirToText(First(gfilelist),Second(gfilelist),   
                             gOffset,gDirChain)

   UpdateScrollbox(gPortal)			    
   DrawScrollbox(gPortal)

   if(gparams.checkfornew)
   {
     newestlabel <- Easylabel("checking for new version", xbase+250, ybase+height+62-80,win,fontsize)

     MoveCorner(newestlabel,xbase+135,ybase+height+65)
#     Draw()

        #newest <- GetHTTPText("pebluser.s3-website-us-east-1.amazonaws.com","/latest.txt")
         newest <- ["0.14",100]
        if(First(newest)==200)
	{
	  newestversion <- Second(newest)
	  if(newestversion == "0.14"+CR(1))
           {
                newlab <- "PEBL Up-to-date: Version:"+newestversion
           } else {
                newlab <- "PEBL Out-of-date: Version "+newestversion+" available."
           }
         } else{
              newlab <- "Version check failed.  Using Version 0.14"
         }
   }else{

    newlab <-"PEBL Version 0.14"
   }

   newestlabel.text  <- newlab
   MoveCorner(newestlabel,xbase+135,ybase+height+65)

   pselected <- -1
   parfiles <- []

   Draw()
   cont <- 1
   while(cont)
    { 


   gPortal.list <- DirToText(First(gfilelist),Second(gfilelist),   
                             gOffset,gDirChain)

   UpdateScrollbox(gPortal)			     
   DrawScrollbox(gPortal)
   gSelected <- gPortal.selected
    
   descname <- DirListToText(gDirChain)+Nth(gflatfilelist,gselected)+".about.txt"
   path.text <- DirListToText(gDirChain)
     MoveCorner(path,xbase+2,ybase-18)

     if(FileExists(descname))
      {

         text <- FileReadText(descname)
	 description.text <-  text 
      } else {
         description.text <- gNoDesc
      }

     screenname <-DirListToText(gDirChain)+Nth(gFlatFileList,gselected)+".png"


     if(FileExists(screenname))
      {
	     RemoveObject(screenshot,win)
	     screenshot <- MakeImage(screenname)

	     AddObject(screenshot,win)

 	     ##scale to 400x300
	     scalew <- 400/screenshot.width  
	     scaleh <- 300/screenshot.height
	     scale <- Min([scalew,scaleh])

	     screenshot.zoomX <- scale
	     screenshot.zoomY <- scale

	     Move(screenshot,780,530-adjust)

      } else {
	  
          ##try to find any .png file, provided it is a  subdirectory
            if(IsDirectory( DirListToText(gDirChain)+
                            Nth(gFlatFileList,gselected)))
	    {
	     list <- GetDirectoryListing( DirListToText(gDirChain)+
                                        Nth(gFlatFileList,gselected))
	     pngs <- Second(FilterDir(list,gDirChain,"*.png"))
             if(Length(pngs)>0)
	     {

       	      RemoveObject(screenshot,win)
              screenname <- DirListToText(gDirChain)+
                         Nth(gFlatFileList,gselected)+"/"+First(pngs)
	      screenshot <- MakeImage(screenname)

	     AddObject(screenshot,win)

 	     ##scale to 400x300
	     scalew <- 400/screenshot.width  
	     scaleh <- 300/screenshot.height
	     scale <- Min([scalew,scaleh])

	     screenshot.zoomX <- scale
	     screenshot.zoomY <- scale

	     Move(screenshot,780,530-adjust)

	     } else {
	     RemoveObject(screenshot,win)
	     screenshot <- screenshotdummy
	     AddObject(screenshot,win)

             }
	     
	    }else{

	     RemoveObject(screenshot,win)
	     screenshot <- screenshotdummy
	     AddObject(screenshot,win)
            }

      }

    prevparfiles <- parfiles
    parfiles <- GetParFiles()   
    if(not ListEqual(prevparfiles,parfiles))
    {
       ##we need to update the pbox here.
       UpdatePulldown(psetbox,parfiles)
       pselected <- psetbox.selected
    }

     Draw()

       vals <- [gPortal,exit,
	   run,subjectbox,fullscreenbox,expbox,langbox,
	   addtochain,clearchain,launchchain,viewoutput,viewerror,
	   edit,openmanual,launchsize,visitweb,about,
	   description,demobox,savechain,loadchain,wiki,
           subplusbutton,clobox,filter,donate,review,
           screenselection, randomizeChainBox,params,
	   combinedata,psetbox]

      returns <- 		   [1,4,
				   6,7,8,9,10,
				   11,12,13,14,15,
				   16,17,18,19,20,
				   21,22,23,24,25,
				   26,27,28,29,30,
				   31,32,33,34,35]

   resp <-  WaitForButtonClickOnTarget(vals,returns)
   tmp <- First(resp)
		
   if(tmp==1)  #Click was on the portal.
      {
         event <- ClickOnScrollbox(gPortal,gClick)
         newselected <- gPortal.selected

	 ##Most of the updates only matter if we did a selection action.
	 if(event == "<select>")
	 {
          if(gselected == newselected)
	   {
             Print("New thing is selected") 
             ##We are selecting something we just selected.open 
              ##directory
              if(IsDirectory(DirListTotext(gDirChain)+Nth(gFlatFileList,gselected)))
                {		

                 Print("DIRCHAIN:")
		 Print(gDirChain)
                  gDirChain <- AppendDirlist(gDirChain,Nth(gFlatFileList,gselected))
 
	          if(Length(gDirChain)<(Length(selectstack)+1))
                    {	
    	              ##we are backing up. (i.e., ../ was clicked on)

	              last <- Nth(selectstack,Length(selectstack))
                       gselected <- First(last)
                       gPortal.selected <- First(last)

   	             ##Remove the last item.
		      if(Length(selectstack)<=1)
                      { 
                       selectStack <- []
                      } else {
                        selectStack <-SubList(selectstack,1,Length(selectstack)-1)
	       	      }
       	   	      gfilelist <- FilterDir(GetDirectoryListing(DirlistToText(gDirChain)),
                                                     gDirChain,First(gFilters))
                      gFlatFileList <- Flatten(gfilelist)

                   }elseif(Length(gDirChain)>Length(selectstack))
                    {
		       Print("New subdirectory")
                       #We opened a new subdirectory.
                        selectStack <- Append(selectstack,[gselected, gOffset])
                  	pselected <- -1
        	        gfilelist <-  FilterDir(GetDirectoryListing(DirlistToText(gDirChain)),
                                                  gDirChain,First(gFilters))
         	        gFlatFileList <- Flatten(gfilelist)
                       gselected <- gPortal.selected

                  } else {
		      Print("same-clicking")
		      gselected <- newselected
                  }

         }}}else{

	 ##update selection stuff.
	 gSelected <- newselected
	 newselected <- gPortal.selected
      }
      }elseif(tmp==4) ##Exit
      {


           PushButton(exit,[0,0])
	   Saveconfig(gconfigname)

	     cont <- 0
      }elseif(tmp==6) ##hit 'run'
      {
           PushButton(run,[0,0])
          if(IsDirectory(DirListTotext(gDirChain)+Nth(gFlatFileList,gselected)))
         {		
             gDirChain <- AppendDirlist(gDirChain,Nth(gFlatFileList,gselected))
             gfilelist <- FilterDir(GetDirectoryListing(DirlistToText(gDirChain)),
                                            gDirChain,First(gFilters))
             gFlatFileList <- Flatten(gfilelist)
 	    gselected <- Length(First(gfilelist)) + 1
	   if(gselected > Length(gFlatFileList))
            {
              gselected <- 1 
            }
	   gOffset <- 0


         } else {

       	  if(gnimhdemographics)
    	  {
	      	  GetNIMHDemographics(gsubcode,win,"demographics-log.csv")
          }

	     paramindex <- psetbox.selected

	     if(paramindex==0)
	     { 
                 paramset <- "default"
             }else{
  	         paramset <- Nth(psetbox.list,paramindex)
             }


             RunScript(gDirChain,Nth(gFlatFileList,gselected),gfullscreen,
                       glanguage,logfile,gsubcode,gexperimenter,paramset)


          if(gAutoSubCode)
           {
	         gSubCode <- (ToNumber(gSubCode)+1)+""
			 subjectbox.text <- gSubCode
           }

          }
      }elseif(tmp==7)  ##Change subject code
      {
	   
       ##subject box
	   Show(subboxhighlight)
	   relx <- First(gClick) - (subjectbox.x )
	   rely <- Second(gClick) - (subjectbox.y )

	   subjectbox.cursorpos <-    (GetTextBoxCursorFromClick(subjectbox,relx,rely))

	   Draw()
	   gsubcode <- GetInput(subjectbox,"<return>",1)
	   Hide(subboxhighlight)
	   
      }elseif(tmp==8)
      {
         ClickCheckBox(fullscreenbox,[0,0])
	 gfullscreen <- fullscreenbox.state

      }elseif(tmp==9)  ##Change experimenter code
      {
       ##experimenter box
	   Show(expboxhighlight)
	   relx <- First(gClick) - (expbox.x )
	   rely <- Second(gClick) - (expbox.y )
	   cursorpos <- GetTextBoxCursorFromClick(expbox,relx,rely)
	   expbox.cursorpos<-cursorpos
	   Draw()
	   experimenter <- GetInput(expbox,"<return>",1)
	   Hide(expboxhighlight)
	   
      }elseif(tmp==10)  ##Change language code
      {

       ##languagebox
	   Show(langboxhighlight)
	   relx <- First(gClick) - (langbox.x )
	   rely <- Second(gClick) - (langbox.y )
	   cursorpos <-  GetTextBoxCursorFromClick(langbox,relx,rely)
	   langbox.cursorpos <- cursorpos 
	   Draw()
	   gLanguage <- GetInput(langbox,"<return>",1)
	   Hide(langboxhighlight)
	   

      }elseif(tmp==11)  ##Add to chain
      {

	 PushButton(addtochain,[0,0])

  	 fname <- Nth(gFlatFileList,gselected)
	 if(IsPEBLFile(fname))
         {
	     paramindex <- psetbox.selected
	     if(paramindex==0)
	     { 
                 paramset <- "default"
             }else{
  	         paramset <- Nth(psetbox.list,paramindex)
            }
  	    gexpchain <- Append(gexpchain,[gDirChain,
                                           fname,paramset])
	    chainlist.text <- MakeExpChainText(gexpchain)
         }

	   
      }elseif(tmp==12)  ##clear chain
      {
	    PushButton(clearchain,[0,0])
            gexpchain <- []        
    	    chainlist.text <- MakeExpChainText(gexpchain)
	   
      }elseif(tmp==13)  ##launch chain
      {
         PushButton(launchchain,[0,0])
	 if(gnimhdemographics)
	  {
              GetNIMHDemographics(gSubcode,win,"demographics-log.csv")
          }

          if(gRandomizeChain)
	  {
	    chain <- Shuffle(gexpchain)
	  } else{
            chain <- gexpchain
	  }

   	  loop(i,chain)
          {
  	    dc <- First(i)
            fname <- Second(i)
	    psettext <- Third(i)

            RunScript(dc,fname,gfullscreen,glanguage,logfile,gsubcode,gexperimenter,psettext)
          }
   
      ##Increment subject code after you run
      if(gAutoSubCode)
         {
           gSubCode <- (ToNumber(gSubCode)+1)+""
	       subjectbox.text <- gSubCode
         }

      }elseif(tmp==14)  ##View debug output
      {

         PushButton(viewoutput,[0,0])
         file <- DirListToText(gDirChain)+"stdout.txt"	 
	 if(FileExists(file))
	 {
            LaunchFile(file)
	 }else{
  	   PopupMessageBox("Unable to find file: ["+file+"]",win)
         }
      
      }elseif(tmp==15)  ##View error output
      {
         PushButton(viewerror,[0,0])
         file <- DirListToText(gDirChain)+"stderr.txt"	 
	 if(FileExists(file))
	 {
            LaunchFile(file)
	 }else{
  	   PopupMessageBox("Unable to find file: ["+file+"]",win)
         }

      }elseif(tmp==16)  ##Edit script
      {
         PushButton(edit,[0,0])

	    file <- DirListToText(gDirChain)+Nth(gFlatFileList,gselected)
  	    if(FileExists(file))
	    {
              LaunchFile(file)
	    }else{
  	      PopupMessageBox("Unable to find file: ["+file+"]",win)
            }

      }elseif(tmp==17)  ##Open Manual
      {   
          PushButton(openmanual,[0,0])
          #SystemCall(gManualLoc,"")	  
          #Print(gManualLoc)
          
		  LaunchFile(gManualLoc)
        
      }elseif(tmp==18)  ##Launcher Size
      {
	 PushButton(launchsize,[0,0])
         #LaunchFile("https://fundry.com/project/69-pebl")
	 if(gScreenSize=="small")
	 {
	   gScreenSize <- "large"
	 } else {
           gScreenSize <- "small"
         }
       Saveconfig(gconfigname)
       PopupMessageBox(gRelaunchMessage,win)

      }elseif(tmp==19)  ##Visit web
      {
         PushButton(visitweb,[0,0])
         #SystemCall("http://pebl.sourceforge.net","")	  
	 Launchfile("http://pebl.sourceforge.net")	  
	   

      }elseif(tmp==20)  ##About
      {
	   PushButton(about,[0,0])
	   MessageBox(gAboutText,win)
      } elseif(tmp==21) ##edit description
      {
        if(gEditDescription)
         {
           #

          if(GetSystemType()=="LINUX")
          {
    	   relx <- First(gClick) - (description.x )
           rely <- Second(gClick) - (description.y )
    	   cursorpos <-  GetTextBoxCursorFromClick(description,relx,rely)
           description.cursorpos <- cursorpos 
     	   Draw()
  	        desctext <- GetInput(description,"<return>",1)
           descname <- DirListToText(gDirChain)+Nth(gFlatFileList,gselected)+".about.txt"
           outfile <- FileOpenOverWrite(descname)
           FilePrint(outfile,desctext)
           FileClose(outfile)

         	#SystemCall(gViewerCommand + " " + DirListToText(gDirChain)+Nth(gFlatFileList,gselected)+".about.txt&")
          } else {
            LaunchFile(DirListToText(gDirChain)+Nth(gFlatFileList,gselected)+".about.txt")
          }
         }
      }elseif(tmp==22)
      {
            ClickCheckBox(demobox,[0,0])
            gnimhdemographics <- demobox.state

      }elseif(tmp==23)  ##sAVE CHAIN
      {
         PushButton(savechain,[0,0])
         Saveconfig(gconfigname)


      }elseif(tmp==24)  ##loadchain
      {

	     PushButton(loadchain,[0,0])
	     gConfigname <- GetEasyInput(gConfigNameText,win)
		 ReadConfigFile(gConfigName)


         ##fullscreen may have been changed when config was read in.

	SetCheckBox(fullscreenbox,gFullScreen)
        SetCheckBox(demobox,gNIMHDemographics)
        SetCheckBox(randomizechainBox,gRandomizeChain)
        chaintitle.text  <- gExpChainText+gConfigName
        chainlist.text <- MakeExpChainText(gexpchain)

      }elseif(tmp==25)  ##Visit wiki
      {
        PushButton(wiki,[0,0])
         #SystemCall("http://pebl.sourceforge.net","")	  

       if(Length(gDirChain)>1)
       {
         root <- Nth(gDirChain,Length(gDirChain))+"/"
       }  else {
	     root <- ""
       }
       wikipagename <- root+Nth(gFlatFileList,gselected)
	   if(wikipagename=="." or wikipagename=="..")
        {
         wikipagename <- "Main_Page"
        }
	   Launchfile("http://pebl.sourceforge.net/wiki/index.php?title="+wikipagename)
      
      } elseif(tmp==26)
      { 

	    gSubCode <- (ToNumber(subjectbox.text)+1)+""
            subjectbox.text <- gSubCode
	    PushButton(subplusbutton,[0,0])

      } elseif(tmp==27)
      { 

       ##Command-line box
	   relx <- First(gClick) - (clobox.x )
	   rely <- Second(gClick) - (clobox.y )

	   clobox.cursorpos <-  GetTextBoxCursorFromClick(clobox,relx,rely)
	   Draw()
	   gCommandLineText <- GetInput(clobox,"<return>",1)
	   Hide(cloboxhighlight)

      } elseif(tmp==28)
      { 

       PushButton(filter,[0,0])
       gFilters <- Rotate(gFilters,1)
       filter    <- MakeButton(First(gFilters),filter.x,filter.y,win,172)
       gfilelist <-  FilterDir(GetDirectoryListing(DirlistToText(gDirChain)),gDirChain,First(gFilters))
       gFlatFileList <- Flatten(gfilelist)

      }elseif(tmp==29)  ##29 == donate 
       {		
         PushButton(donate,[0,0])

if(0)
{
	 fname <-DirListToText(gDirChain)+ Nth(gFlatFileList,gselected)

		 if(IsDataFile(fname))
         {

			bg1 <- Rectangle(550,400,700,800,MakeColor("black"),1)
			bg <- Rectangle(750,400,490,790,MakeColor("grey"),1)

			AddObject(bg1,win)			
			AddObject(bg,win)


			header <- EasyLabel("Transmit data file to server.",750,20,win,30)
			message <- EasyLabel("Enter IP address or hostname:",750,60,win,22)
			message2 <- EasyLabel("",750,80,win,22)
			
			entry <- EasyTextBox(gDefaultHostName,550,100,win,16,400,20)
                        address <- GetInput(entry,"<return>")
			gDefaultHostName <- entry.text
			Draw()



			text <- FileReadText(fname)

			message.text <-"Opening connection to host: "+address
			Draw()

			starttime <- GetTime()
			network <- 0
			message2.text <- "waiting"

			secs <- 0

			
			while(network==0 and secs < 10)
 			{

 	                   network <- ConnectToHost(address,4444)			     
			   time <- Floor((GetTime()-starttime)/1000)
			   
			  
			   if(time > secs)
			   {

			     secs <- time
                              message2.text <- message2.text + "."
			     Draw()
                            }
			}			

			if(network==0)
			{
			   message.text <- "Unable to make connection to host."
			   message2.text <- "Press any key to return."
			   Draw()
			} else {

			   message.text <- "Connected to host. Sending data."
			   Draw()

			    SendFile(network,fname,"USER"+RandomDiscrete(10000),message)
			    message.text <-  "Data sent."
 	  	 	    message2.text <- "Press any key to return."
             	            CloseNetworkConnection(network)
			}

			Draw()
			RemoveObject(bg1,win)
			RemoveObject(bg,win)
			RemoveObject(entry,win)
			RemoveObject(message,win)
			RemoveObject(message2,win)
			RemoveObject(header,win)

			WaitForAnyKeyPress()
          }


      	   Draw()

         } else {
           PopupMessageBox("Not implemented",win)
         }

		 
       } elseif(tmp==30) ##write review
	   {
 	     PushButton(review,[0,0])
	     Launchfile("http://sourceforge.net/projects/pebl/reviews/")
	   
       }elseif(tmp==31)  ##Change screen resolution.
         {       



          resolutions <- UpdateScreenResPulldown(screenselection)
	  PullDown(screenselection,gClick)
	  Draw()
          choice <- screenselection.selected ##index chosen.


       if(choice ==screenselection.numitems)
	   {
	     ##get custom screen size:

	      xy <- [screenselection.x+screenselection.width/2,
                      screenselection.y+screenselection.height/2]
              width <- ToNumber(PopUpEntryBox(gGetWidthText,win,xy))
              height <- ToNumber(PopUpEntryBox(gGetHeightText,win,xy))
	      gCustomScreenRes <-  width+"x"+height
#              UpdateScreenResPulldown(screenselection)
	      ##reset to choice
	      screenselection.selected <- choice
	      DrawPulldown(screenselection)	      
	      gScreenRes <- gCustomScreenRes	      
	      Draw()

	   } elseif(Nth(screenselection.list,choice) == gCurrent)
	   {
            ##Use the current screen resolution:
	    gScreenRes <- gCurrent

	   } else {
	      #Use the specified resolution.
	      res <- Nth(resolutions,choice)
              gScreenRes <- First(res)+"x"+Second(res)
	   }

         

     }elseif(tmp==32)
      {
       ClickCheckBox(randomizechainbox,[0,0])
       gRandomizeChain <- randomizechainbox.state

      }elseif(tmp==33)
      {
       ##Set/edit parameters. 
       PushButton(params,[0,0])

       paramindex <- psetbox.selected
       if(paramindex==0)
         {
            paramset <- "default"
          }else{
           paramset <- Nth(psetbox.list,paramindex)
          }
       SetParameters(gDirChain,Nth(gFlatFileList,gselected),win,paramset)

      } elseif(tmp==34)
      {
        ##Combine data dialog, which is really a separate PEBL program.
        PushButton(combineData,[0,0])
        CombineDataDialog(gDirChain,Nth(gFlatFileList,gselected),logfile)
      }elseif(tmp==35)
      {
       ##get the parameter files we want.

       if(Length(parfiles)>1)
       {
        Pulldown(psetbox,gClick)
        pselected <- psetbox.selected
       }


      }


#     Draw()
   }


}

define CombineDataDialog(dirChain,filename,logfile)
{
 ##this would work, but it runs blocking the current app. so reconstruct runscript.
##  RunScript(dirchain, "combinedatafiles.pbl",0,gLanguage, logfile,0,"","")

   Print(filename)
   type <- GetSystemType()
   if(type== "LINUX" or type=="OSX")
   {
     sep <- " ; "
   } else {
     sep <- " & "
   }
   
  ##On windows, should the launcher run from a PEBL subdirectory rather than C:\Program Files\pebl
   if(gUseReloc)
     {

        sep <- CR(1)
        gPEBLName <- "\bin\pebl.exe"  ##The relative location should be bin\pebl.exe
  	    callstring <- "set ABSPATH=%CD%"+sep+"cd " + DirListToText(dirchain) + sep + gQuote+"%ABSPATH%\PEBL" +gPEBLName +gQuote + " " +  gQuote + "combinedatafiles.pbl"+gQuote

     }else {
         
	 callstring <- "cd " + DirListToText(dirChain) + sep  + gPEBLName + " "  +gQuote+ "combinedatafiles.pbl"+gQuote 

      }

     callstring <- callstring + " --language " + glanguage  +" &"

     if(type =="LINUX" or type == "OSX" or type == "WINDOWS")
        {
          if(gDebug)
	    {
             if(type == "WINDOWS")
	        {
		   callstring <- callstring + sep+"pause"
		}
             }

	   if(type=="LINUX" or type=="OSX")
             {
                callstring <- callstring + " > stdout.txt 2> stderr.txt"
             }
        }

	##be sure to run in background, if possible.

  if(gUseReloc)
      {
         runfile <- FileOpenOverWrite("tmp.bat")
         FilePrint(runfile,callstring)
         FileClose(runfile)
         SystemCall("tmp.bat","")

      }else{

        Print(callstring)
         Print(SystemCall(callstring,""))
      }
}




##This is a hard-coded filter;
##it will only return .pbl files and directories.
define FilterDir(inlist,path,type)
{

  pathhead <- DirListTotext(path)
  tmpdir <- []
  tmppbl <- []
  loop(i, inlist)
  {

    if(IsDirectory(pathhead+i))
      {
         tmpdir <- Append(tmpdir,i)
      }else{
	  
       if(type=="*.pbl")
       {
       if(IsPEBLFile(i))
        {
            tmppbl <- Append(tmppbl,i)
        }
       } elseif(type=="data files") {
       if(IsDataFile(i))
         {
	     tmppbl <- Append(tmppbl,i)
         }
	        
       } elseif(type=="*.*"){
	   ##no filter:
           tmppbl <- Append(tmppbl,i)
       }elseif(type=="*.png")
       {
         if(IsPNGFile(i))
	 {
           tmppbl <- Append(tmppbl,i)
	 }
       }elseif(type=="*.par")
       {
        if(IsPARFile(i))
	{
          PushOnEnd(tmppbl,i)
	}
       }
 

     }
  }
  return [Sort(tmpdir),Sort(tmppbl)]

}



define DirToText(dirlist,filelist,offset,path)
{ 

  pathhead <- DirListTotext(path)

  tmp <- []
  loop(i,dirlist)
  {
     PushOnEnd(tmp,  i +"\")
  }

  loop(i,filelist)
  {
    PushOnEnd(tmp,  i )
  }

  ##this crashes here sometimes here, let's be sure we access part of the list that we can.
  offset <- Max([0,offset])
  list <- SubList(tmp,offset+1,Length(tmp))
 return list
}

define AppendDirList(dirlist,dir)
{

 if(dir == ".")
   {
     dirlist <- dirlist
   }elseif(not dir == "..")   
   {
      dirlist <- Append(dirlist,dir)
   } else {
      if((not Last(dirlist) == ".") and
	     (not Last(dirlist) == ".."))
	  {
	      dirlist <- SubList(dirlist,1,Length(dirlist)-1)
      } else {
	      dirlist <- Append(dirlist,dir)
      }
   }

   return dirlist
}


##appends a set of nested directories into a path.
define DirlistToText(list)
{
  tmp <- ""
  if(GetSystemType()=="WINDOWS")
    {
	   sep <- "\"
	} else {
	   sep <- "/"

	}
  loop(i,list)
  {		 
     tmp <- tmp + i+ sep
  }
  return tmp
}


##This saves a table (nested list) to a file
##it is used to save the .config files
define  FileSaveTable(table,filename)
{
   ##Not clear why we are using global here rather than the passed-in value.
   ##filename <- gconfigName+".config"
   outfile <- FileOpenOverwrite(filename)  ##Overwrite whatever we ave, without checking for it.
   loop(i,table)
    {
       FilePrint_(outfile, First(i) + ",")

	   if(IsList(Second(i)))
        {
		   sep <- ""
		   loop(j,Second(i))
           {
		      FilePrint_(outfile,sep+j)
			  sep <- ","
           }
		   FilePrint(outfile,"")
        } else {
		  FilePrint(outfile,Second(i))
        }
    }
  FileClose(outfile)
}


##This makes the text to put in the expchain box.
define MakeExpChainText(expchain)
{
  tmp <- ""
  loop(i,expchain)
    {
         Print(i)
 	 tmp <- tmp +DirlistToText(First(i))+Second(i) + " --pfile "+Third(i)+ CR(1)  
    }
  return tmp	
}


define RunScript(dirChain,filename,fullscreen,language,logfile,subcode,experimenter,pset)
{
  ##Additional command-line parameters that should be hardcoded:
  ## put --driver  --video, etc. here. 
  gCommandLineAdd <- " " + gCommandLineText

   type <- GetSystemType()
   if(type== "LINUX" or type=="OSX")
   {
     sep <- " ; "
   } else {
     sep <- " & "
   }
   
  ##On windows, should the launcher run from a PEBL subdirectory rather than C:\Program Files\pebl
   if(gUseReloc)
     {
       Print(gPEBLName)
        sep <- CR(1)
        gPEBLName <- "\bin\pebl.exe"  ##The relative location should be bin\pebl.exe
		callstring <- "set ABSPATH=%CD%"+sep+"cd " + DirListToText(dirchain) + sep + gQuote+"%ABSPATH%\PEBL\" +gPEBLName +gQuote+ " " +filename + " -s " + subcode
    		 ##callstring <- "set ABSPATH=%CD%"+gPEBLname+ CR(1)+ " cd "+DirListToText(dirchain)+CR(1)+gQuote+"%ABSPATH%"+gquote + " " + filename +" "  

     }else {
         
    		 callstring <- "cd " + DirListToText(dirChain) + sep  + gPEBLName + " "  +gQuote+filename+gQuote + " -s " + subcode
##    		 callstring <-  gPEBLName + " "  +gQuote+filename+gQuote + " -s " + subcode


      }


      ##Get the current screen size to use for launching experiments,
      ##the preferred size should be set or read in from config file.
      ## if we are not fullscreen.
     if(gScreenRes == gCurrent)
      {
        gScreenResLine <- ""
      }else  {
        gScreenResLine <- "--display " + gScreenRes
      }


       if(fullscreen)
         {
	     callstring <- callstring + " --fullscreen " + gScreenResLine

         }else{
              ##If not fullscreen, use something sligtly smaller
              ##to make way for toolbars etc.
             callstring <- callstring + " " + gScreenResLine
          }

	  if(not pset == "")
           {
             callstring <- callstring + " --pfile " + pset
           }

	    callstring <- callstring + " --language " + language  + " " + gCommandLineAdd
  
          if(type =="LINUX" or type == "OSX" or type == "WINDOWS")
           {
	      if(gDebug)
		    {
			  if(type == "WINDOWS")
			    {
				   callstring <- callstring + sep+"pause"
				}
			}else{
                callstring <- callstring + " > stdout.txt 2> stderr.txt"
                }
		   }
		 
         FilePrint(logfile,TimeStamp() + "," + DirListToText(dirChain)+ filename+","+GetPEBLVersion() + "," + experimenter + "," + subcode + "," +"fullscreen:["+fullscreen+"],"+ language + "," + callstring+ ","+"STARTED")

         #### Run the experiment!!!!
         Print("Executing : [" + callstring + "]")

  if(gUseReloc)
      {

          runfile <- FileOpenOverWrite("tmp.bat")
     ##     FilePrint(runfile,callstring+sep+"pause") ##Use for debugging purposes.
          FilePrint(runfile,callstring)
          FileClose(runfile)
          SystemCall("tmp.bat","")
      }else{
         Print(SystemCall(callstring,""))
      }

         FilePrint(logfile,TimeStamp() + "," + DirListToText(gDirChain)+filename+","+GetPEBLVersion() +
		 "," + experimenter + "," + subcode + "," +"fullscreen:["+fullscreen+"],"+ language + "," + callstring+ ","+"FINISHED")

}



define IsPEBLFile(fname)
{

  returnval <- 0
  len <- StringLength(fname)	
  if(len>4)	
           {
            if(SubString(fname,len-3,len)==".pbl")
	     			{
					  returnval <-  1
                    }

          }
   return returnval
}

define IsparFile(fname)
{

  returnval <- 0
  len <- StringLength(fname)	
  if(len>4)	
           {
            if(SubString(fname,len-3,len)==".par")
		{
			  returnval <-  1
                 }

          }
   return returnval
}


define IsDataFile(fname)
{

  returnval <- 0
  len <- StringLength(fname)	
  if(len>4)	
           {
		   tmp <- SubString(fname,len-3,len)
            if(tmp==".csv" or tmp == ".dat" or tmp == ".txt") 
    			{
					  returnval <-  1
                }

          }
   return returnval
}

define IsPNGFile(fname)
{

  returnval <- 0
  len <- StringLength(fname)	
  if(len>4)	
           {
           if(Lowercase(SubString(fname,len-3,len))==".png")
	     	{
					  returnval <-  1
                }

          }
   return returnval
}





define ReadConfigFile(configname)
{

##This reads in some configuration stuff from the current
## config file.

   if(FileExists(configName+".config"))
      {
           config <- (ReadCSV(gConfigName+".config"))
	   
	   ##read in the keys--first characters.
	   keys <- []
	   loop(i,config)
	   {
	     keys<- Append(keys,First(i))
           }

	   tmpres <- First(gScreenResInitial)+"x"+Second(gScreenResInitial)
	   gScreenRes <- GetConfig("screenres",keys,config,tmpres)
	   gScreenSize <- GetConfig("screensize",keys,config,"large")
	   gfullscreen <- ToNumber(GetConfig("fullscreen",keys,config,0))
	   gnimhdemographics <- ToNumber(GetConfig("nimhdemo",keys,config,0))
	   gsubcode    <- GetConfig("subcode",keys,config,"0")
	   if(gAutoSubCode)
            {
	     gSubCode <- (ToNumber(gSubCode)+1)+""
            }


	   gDefaultHostName <- GetConfig("ipaddress",keys,config,"localhost")
	   gCommandLineText <- GetConfig("commandline",keys,config,"")
	   gexperimenter <-GetConfig("experimenter",keys,config,"default")
	   glanguage <-GetConfig("language",keys,config,"en")
	   gRandomizeChain <- ToNumber(GetConfig("randomizechain",keys,config,0))
   	   gexpchain <- []         ##sequence of experiments to run
   	   ##Get all config entries named 'expchain'
	   chains <- Filter(config,Match(keys,"EXPCHAIN"))
	   loop(i,chains)
            {
	      Print("Reading " +i)  
              PushOnEnd(gexpchain, 
                   [SubList(i,4,Length(i)),Second(i),Third(i)])
            }  

      } else {
      ##We don't have a config file.
        gDefaultHostName <- "localhost"
        gCommandLineText <- ""
        gfullscreen <- 0
        gsubcode <- "1"
        gexperimenter <- "default"
        glanguage <- "en"
        gexpchain <- []         ##sequence of experiments to run
	gnimhdemographics <- 0
	gScreenSize <- "large"
        gScreenRes <-  First(gScreenResInitial)+"x"+Second(gScreenResInitial)
	gRandomizeChain <- 0
      }

}

define Saveconfig(configname)
{

    ##save settings on exit.
	out <- [["fullscreen",gfullscreen],
                ["subcode",gsubcode],
                ["experimenter",gexperimenter],
	        ["language",glanguage],
	        ["nimhdemo",gnimhdemographics],
	        ["commandline",gCommandLineText],
	        ["ipaddress",gDefaultHostName],
		["screensize",gScreenSize],
		["screenres",gScreenRes],
		["randomizechain",gRandomizeChain]
               ]
            

	  ##each element of gExpChain has three parts:
	  ##1. a list containing the path chain (variable length)
          ##2. the script name
 	  ##3. the parameter file (could be default)

          Print("saving expchaing")
	  loop(i,gexpchain)
          {

	     ##we need to save 1. script name, 2. parameter file, 3 path
	     ilist <- Flatten([Second(i),Third(i),First(i)])
	     PushOnEnd(out,["EXPCHAIN",ilist])
           }
      FileSaveTable(out,configname+".config")
}



define UpdateCapturedThumb(p)
{

   time<- GetTime()

   if(time-gLastUpdate > 5)
    {
     mousexy <- GetMouseCursorPosition()
     UpdatePortalXX(mousexy)
     gLastUpdate <- time
     Draw()
    }

  
}

##this should update the file list given mouse position
define UpdatePortalXX(mousexy)
{

	mousey <- Second(mousexy)
	filelen <- Length(gFlatFileList)
	##compute the offset needed for the file window:
	if(filelen <= gPortalNum)
         {
           gOffset <- 0
         } else {
	 
          ##force proportion to be between 0 and 1:
	  proportion <- Min([Max([ ((mousey - gPortal.y)/gPortal.height),0]),1.0])

	  ##compute new gOffset. 
          ##filelen is the number of files in the listing.
          ##gportalnum is the size of the portal window in file rows.
          ##



	  ##Figure out where the gOffset should be.  gOffset is the
	  ##number of files down the list we actually want to display.
	  gOffset  <- Max([0,Floor(proportion * (filelen - gPortalNum))])

          if(gselected<=gOffset)
           {
  	    gselected <- gOffset + 1
           }
          if(gselected > gOffset+gPortalNum)
           {
   	    gselected <- gOffset+gPortalNum
           }


         ##move the thumb to the right spot.

	 gThumb.y <-  Max([Min([mousey, gPortal.y+gPortal.height-gutter*2-1]),gPortal.y+gutter*2+1])
         gSelection.y <- gPortal.y+gyheight*(gselected-.5-gOffset)
         gPortal.text <- DirToText(First(gfilelist),Second(gfilelist),gOffset,gDirChain)
             

}
}
##this supposedly gets called on a mouse release event?
##it should also get called when you leave the window...
define CLEARTHUMBCAPTURE(p)
{

		##you should update the thumb here!
                mousexy <- GetMouseCursorPosition()
		#UpdatePortal(mousexy)
		gKeepLooping <- 0
		Draw()
}



define GetStrings(lang)
{
       gRunText <- "Run selected script"
       gEditParams <- "Edit"

	gOpenText <- "Open"
	gExitText <- "EXIT"
	gViewDebugText <- "View debug output"
        gViewErrorText <- "View error output"
        gCombineDataText <-"Combine data"
        gAddToChainText <- "Add to Chain"
	gClearChainText <- "Clear Chain"
	gSaveChainText <- "Save Chain"
	gLoadChainText <- "Load Chain"
        gRandomizeChainText <- "Randomize Chain"

	gOpenManualText <- "Open Manual"
	gAboutLabelText <- "About"
	gSizeText <- "Size: "
	gwebtext <- "Visit Website"
	gWikiText <- "Wiki"
	gLaunchChainText <- "Launch Chain"
    gNoDesc <- "Please cite PEBL if you use it:"+CR(1)+"Mueller, S. T., & Piper, B. J. (2014). The Psychology Experiment Building Language (PEBL) and PEBL Test Battery. Journal of neuroscience methods (222), 250–259."
    gPEBLTitle <- "PEBL Launcher for "
    gPartCode <- "Participant Code:"
    gCustomText <- "Custom:"
    gCurrent <- "Current"
    gGetWidthText <- "Enter custom width in pixels:"
    gGetHeightText <- "Enter custom height in pixels:"
	gExperCode <- "Experimenter:"
	gCommandLineOptions <- "Command line options:"
	gParameterLabel <- "Parameters:"
	gLangcode  <- "Language:"
	gFulltext <- "Fullscreen"
	gCollectDemoText <- "Collect demographics"
    gScreenResLabel <- "Screen resolution:"

    gExpChainText <- "Experiment Chain:"
    gConfigNameText <- "Config name?"
    gRelaunchMessage <- "Please exit the launcher and restart."
    gChooseScreenText <- "Choose screen resolution to use"
    gAboutText <-"PEBL is a system for creating and running psychology experiments.  It is developed by Shane T Mueller, Ph.D., and includes more than 50 standard psychology lab experiments.  You can use PEBL to create your own tests or modify previous ones FREE OF CHARGE. Find out more at http://pebl.sf.net

This launcher is written in PEBL itself, allowing a fairly uniform launcher on all platforms. Only .pbl  files and directories are shown in the file window--use your file manager to get the data after your experiment is complete. Click on a directory that has been selected to open it.  Add scripts to the experiment chain window to run a sequence of experiment in a row, all using the same subject code.  

 *The file [PEBLLaunch-log.txt] contains a log of every experiment launched from the launcher.
 *Debug output from each script (using the Print() command) is saved in the file [stdout.txt] file in a script's directory.
 *Error and automatic messages from each script are saved in the file [stderr.txt] in a script's directory."



  lang <- Uppercase(lang)
  if(lang == "ES")
   {
    gRunText <- "Ejecutar script seleccionado"
    gOpenText <- "Abre"
    gExitText <- "EXIT"
    gViewDebugText <- "Ver la salida de depuración"
    gViewErrorText <- "Ver la salida de error"
    gCombineDataText <-"Combinar data"
    gAddToChainText <- "Añadir a la cadena"
    gClearChainText <- "Borrar la cadena"
    gSaveChainText <- "Guardar la cadena"
    gLoadChainText <- "Cadena de carga"
    gOpenManualText <- "Abrir Manual"
    gAboutLabelText <- "Acerca de"
    gSizeText <-"Size: "
    gwebtext <- "Página Web"
    gWikiText <- "Wiki"
    gLaunchChainText <- "Lanzamiento de la cadena"
    gNoDesc <- "La descripción no encontrado"
    gPEBLTitle <- "PEBL Launcher para "
    gPartCode <- "Código de Participante:"
    gExperCode <- "Experimentador"
	gCommandLineOptions <- "Command line options:"
    gLangcode <- "Idioma:"
    gFulltext <- "Pantalla Completa"
    gScreenResLabel <- "Screen resolution:"
    gCustomText <- "Custom:"
    gCurrent <- "Current"
    gCollectDemoText <- "Recoger datos demográficos?"
    gChooseScreenText <- "Choose screen resolution to use"
    gExpChainText <- "Experimento de la cadena:"
    gConfigNameText <- "nombre de configuración?"
    gRelaunchMessage <- "Please exit the launcher and restart."
    gAboutText <- "Spanish Translation courtesy automated translation. PEBL es un sistema de creación y ejecución de experimentos de psicología Es desarrollado por Shane T Mueller, Ph.D., e incluye más de 50 experimentos de laboratorio estándar de la psicología Puede utilizar PEBL para crear sus propias pruebas o modificar la anterior. los GRATUITO. Más información en http://pebl.sf.net

Este lanzamiento está escrito en PEBL sí mismo, permitiendo que un lanzador bastante uniforme en todas las plataformas. . Sólo los archivos y directorios pbl se muestran en la ventana del archivo - utilizar su gestor de archivos para obtener los datos después de la prueba se ha completado. Haga clic en un directorio que ha sido seleccionada para abrirlo. Agregar secuencias de comandos a la ventana de la cadena de experimento para ejecutar una secuencia de experimentos en una fila, todas ellas con el código mismo tema.

 * El archivo [PEBLLaunch-log.txt] contiene un registro de todos los experimentos en marcha del lanzador.
 * La salida de depuración de cada secuencia de comandos (usando la Print() comando) se guarda en el archivo el archivo [stdout.txt] en el directorio de un script.
 * Mensajes de error y automática de cada secuencia de comandos se guardan en el archivo [stderr.txt] en el directorio de una secuencia de comandos."

   }
}



## This should be received with ReceiveText(network)
define SendText(network,text)
{
   len <- StringLength(text)
   
   Print("Sending: [" + ZeroPad(len,10)+"]")

   SendData(network,ZeroPad(len,10))
   SendData(network,text)
   

}


define ReceiveText(network)
{
	len <- ToNumber(GetData(network,10))
	text <- GetData(network,len)
	return text
}


## a robust version of lookup:
define GetConfig(key, keys, database,empty)
{
   line <- Lookup(key,keys,database)
   if(Length(line)==0)
   {
    ret <- empty
   }else{
   ret <- Second(line)
   }
  return ret
}






## This sends a file using a direct tcp/ip connection, using
## a special file protocol.
##

define SendFile(network,filename,id,label)
{ 
   Print("loading filename: ["+filename+"]")
   text <- FileReadText(filename)
   length <- StringLength(text)+""
   
   if(StringLength(length)>16)
   {
     SignalFatalError("Cannot send a file this long:"+length)
   }

   Print("Sending: [" +id +"] : "+length)
   message <-  Format(id,32)+Format(length,16) + text
   label.text <-"Attempting to send data to server (up to 10 secs)"
   Draw()
   Wait(500)
   success <- SendData(network,message)
   if(success)
   {
      label.text <- "Succeeded at sending data"
      Draw()
      Wait(500)
   } else {
      label.text <- "Failed to send data.  Please try again later or send data files directly. Press any key to begin."
      Draw()
      WaitForAnyKeyPress()
   }
   return success
}

##  This is the installer code that gets run if the right Documents 
##  directory does not exist.
##  Otherwise, the normal launcher will run.
##
define RunFirstTime(p)
{
    Print("running first time inside")
    Print(p)
   if(Length(p)>1)
     {

   	 resources <- Nth(p,1)
     ##Print("Resources:" + resources)
	 targetdir <- Second(p)
	 home <- targetdir

	} else {
    	 Print("using default resources")
   	    if(GetSystemType()=="OSX")
		  {
	           resources <- "/Applications/pebl.app/Contents/Resources"

  		  } elseif(GetSystemType()=="WINDOWS")
                    {
                      ##Check here for robustness.
            if (FileExists("%ProgramFiles(x86)%"))
 		     {
		       resources <- "%ProgramFiles(x86)%\\PEBL"
		      } else {

		       resources <- "%ProgramFiles%\\PEBL"
		      }

		  }else {
		   ##linux.  this is hardcoded right now, but should be
		   ##made more portable:
		   resources <- "/usr/share/pebl"
		   if(not FileExists(resources))
		   {
  		     resources <- "/usr/local/share/pebl"
		   }

		   if(not FileExists(resources))
		   {
  		     resources <- "../"
		   }
		   

		   if(not FileExists(resources))
		   {
 		     SignalfatalError("Unable to find installed PEBL resource directory")
		   }
		   
                  }

	 }

	if(0)
	 {
     ##We possibly need to hard-code this.
   
       if(GetSystemType()=="OSX")
	  {
           resources <- "/Applications/pebl.app/Contents/Resources"
      }
     }
	 
	 targetDir <- "pebl-exp.0.14"
	
	
    gVideoWidth <- 800
    gVideoHeight <- 500
    gwin <- MakeWindow("white")
    gSleepEasy <- 1
       
   head1 <- EasyLabel(GetPEBLVersion() + " for " +GetSystemType(),gVideoWidth/2,50,gwin,22)


   pebl <- MakeImage("pebl.png")
   AddObject(pebl,gWin)
   Move(pebl,gVideoWidth/2,125)
   message0 <- "Resources at: ["+resources+"]" +CR(1)+ "HOME at: " + ghome + CR(1)
   message1 <- message0+"By default, PEBL tries to look for files in ["+ghome+"]" + CR(2) +
   "Would you like to create the directory and install some basic experiment scripts?"



   inst <- EasyTextBox(message1,
                        25,200,gwin,15,gVideoWidth-50,130)


if(1)
 {
   yes <- EasyLabel("YES", gVideoWidth/2-50,350,gWin,40)
   no <-  EasyLabel("NO",  gVideoWidth/2+50,350,gWin,40)
   Draw()
   copy <- WaitForClickOnTarget([yes,no],[1,0])
   Hide(yes)
   Hide(no)
 
    Draw()
 
	if(copy)
     {
	 if(GetSystemType()=="OSX")
	  {
         inst.text <- "<"; Draw()
	  SystemCall("mkdir $HOME/Documents/pebl-exp.0.14 > ~/tmp.txt","")
	  SystemCall("cp "+resources+"/fileselect.pbl $HOME/Documents/pebl-exp.0.14/ >> ~/tmp.txt","")
	  SystemCall("cp -R "+resources+"/battery/ $HOME/Documents/pebl-exp.0.14/battery >> ~/tmp.txt","")



###########copy files on windows
       }elseif(GetSystemType()=="WINDOWS"){


      inst.text <- "<"; Draw()
      dest <- ghome
      if(FileExists(ghome+"\Documents"))
	    {
		   doc <- "\Documents"
	    } elseif (FileExists(ghome+"\My Documents"))
		{
		   doc <- "\My Documents"
		} else {
		    #user-selected?
		    doc <- "\My Documents"
		}
		
            dest <- ghome+ doc + "\pebl-exp.0.14" 
 	    #SystemCall("md " + dest +" >> "gHome+"\pebl_install_log.txt","")
	    Print("Creating:"+gQuote+dest+gQuote)
            MakeDirectory(dest)
	    Print(dest+"\battery")
	    MakeDirectory(dest+"\battery")
	    Print(dest+"\demo")
	    MakeDirectory(dest+"\demo")

	 ##copy test battery:
          Print("xcopy "+gQuote+resources+"\battery\*"+gQuote+" "+gQuote+dest+"\battery"+gQuote+" /e")
 	  SystemCall("xcopy "+gQuote+resources+"\battery\*"+gQuote+" "+gQuote+dest+"\battery"+gQuote+" /e","")
        ##Copy demo:
        Print("xcopy "+gQuote+resources+"\demo\*"+gQuote+" "+gQuote+dest+"\demo"+gQuote+" /e")
        SystemCall("xcopy "+gQuote+resources+"\demo\*"+gQuote+" "+gQuote+dest+"\demo"+gQuote+" /e","")
        
        #Print("xcopy "+gQuote+resources+"\demo\*"+gQuote+" "+dest+"\demo"+" /e")
        #SystemCall("xcopy "+gQuote+resources+"\demo\*"+gQuote+" "+dest+"\demo"+" /e","")

        ##Copy doc:
        Print("copy "+gQuote+resources+"\doc\PEBLManual0.14.pdf"+gQuote+" "+gQuote+dest+gQuote)
        SystemCall("copy "+gQuote+resources+"\doc\PEBLManual0.14.pdf"+gQuote+" "+gQuote+dest+gQuote,"")
		
	###########copy files on linux
       }elseif(GetSystemType()=="LINUX"){

      resources <- "../"
      inst.text <- "<"; Draw()
      dest <- ghome
      if(FileExists(ghome+"/Documents"))
       {
	   doc <- "/Documents"
       } 
	
            dest <- ghome+ doc + "\pebl-exp.0.14" 
 	    #SystemCall("md " + dest +" >> "gHome+"\pebl_install_log.txt","")
	    Print("Creating:"+gQuote+dest+gQuote)

            MakeDirectory(dest)
	    Print(dest+"\battery")
	    MakeDirectory(dest+"\battery")
	    Print(dest+"\demo")
	    MakeDirectory(dest+"\demo")

      inst.text <- "<"; Draw()
	  SystemCall("mkdir $HOME/Documents/pebl-exp.0.14 > ~/tmp.txt","")
#      inst.text <- inst.text + "-"; Draw();WaitForDownClick()
#	  SystemCall("cp -R "+resources+"/demo/ $HOME/Documents/pebl-exp.0.14/demo >> ~/tmp.txt","")
#      inst.text <- inst.text + "-"; Draw();WaitForDownClick()
#	  SystemCall("cp "+resources+"battery/fileselect.pbl $HOME/Documents/pebl-exp.0.14/ >> ~/tmp.txt","")
#      inst.text <- inst.text + "-"; Draw();WaitForDownClick()
	  SystemCall("cp -R "+resources+"/battery/ $HOME/Documents/pebl-exp.0.14/battery >> ~/tmp.txt","")
#      inst.text <- inst.text + "-"; Draw();WaitForDownClick()
#	  Systemcall("cp -R "+resources+"/PEBLdrop.app $HOME/Documents/pebl-exp.0.14 >> ~/tmp.txt","")
#      inst.text <- inst.text + "-"; Draw();WaitForDownClick()
#	  Systemcall("cp -R "+resources+"/PEBLdrop\ fullscreen.app $HOME/Documents/pebl-exp.0.14 >> ~/tmp.txt","")
#      inst.text <- inst.text + "-"; Draw();WaitForDownClick()
#	  Systemcall("cp -R "+resources+"/runlauncher.command $HOME/Documents/pebl-exp.0.14 >> ~/tmp.txt","")
#     inst.text <- inst.text + "->"; Draw();WaitForDownClick()
		
	  }


		
	   inst.text <- "Files copied. Next time you run PEBL, it will automatically run the launcher and show you the scripts in Documents/pebl-exp.0.14." + CR(1) +
	    "Click the window to exit."
	  
	 } else {

       inst.text <- "Click window to exit."
	}
 }
	 Draw()
   WaitForDownClick()
   
   
}


## This handles setting parameters for a selected script file.
##
define SetParameters(dirChain,scriptname,win,parname)
{

  path <- DirListToText(dirchain) +"params/"
  schema <- path+scriptname+".schema"
 
  ##this is what will be used for the default param file:
  if(parname=="default")
  {
    paramsfile <- path+scriptname+".par"
    parname <- scriptname+".par"
  }else{
    paramsfile <- path + parname
  }

  fail <- 0

  if((not FileExists(schema)))
   { 
      if(IsPEBLFile(scriptname))
         {
            PopupMessageBox("Schema file does not exist for script ["+scriptname+"]. Schema files are saved in the params\ subdirectory of the script's directory.  Most likely, the parameters of ["+scriptname+"] cannot be set using this interface.",win)
         }else{
            PopupMessageBox("To set parameters, select a .pbl file first. ["+scriptname+"] is not a PEBL script ending with .pbl",win)
         }


     fail <- 1
   }

 if(not fail)
  {
 
  ##Create background over current window.
  rect <- Rectangle(gVideoWidth/2,gVideoHeight/2,gVideoWidth,gVideoheight,MakeColor("grey80"),1)
  AddObject(rect,win)

  header <- EasyLabel("Editing parameters for "+path+scriptname,gVideoWidth/2,20,win,20)
  schemas <- ReadSchemaFile(schema)
  ts <- Transpose(schemas)
  defaults <- Transpose([First(ts),Second(ts)])

  Print("Reading parameters from: " + paramsfile)
  parameters <- CreateParameters(defaults,paramsfile)  
  PrintProperties(parameters)

  changed <- 0


  quit  <- MakeButton("Exit without saving",100,50,win,150)
  save <- MakeButton("Save file and exit",100,72,win,150)

  pnl <- EasyLabel("Parameters:",420,50,win,12)
  parnamebox <- EasyTextBox(parname,420-75,72-10,win,12,250,20)

  add <- MakeButton("New parameter set",260,72,win,150)
#  del <- MakeButton("Remove parameter",260,72,win,150)

  reset <- MakeButton("Reset to defaults",260,50,win,150)

  ##Now, make a grid showing values, etc., in the schema file
  ##We will set the rowheight adaptively..it should be set based on size 
  ##needed, but for now we will just stretch them all equally.

  ##out is [ui,vals,pluses,minuses,pmindex]
  out <- LayoutPGrid(schemas,parameters,win)

  ui <- First(out)
  vals <- Second(out)
  pluses <- Third(out)
  minuses <- Fourth(out)
  pmIndex <- Fifth(out)


  returns <- Sequence(1,Length(vals),1)


##add the click-on values at the end of the lists
  PushOnEnd(vals,save)
  PushOnEnd(vals,reset)
  PushOnEnd(vals,quit)
  PushOnEnd(vals,add)
  PushOnENd(vals,parnamebox)

  PushOnEnd(returns,"save")
  PushOnEnd(returns,"reset")
  PushOnEnd(returns,"quit")
  PushOnEnd(returns,"add")
  PushOnEnd(returns,"parnamebox")

##add the plus/minuses now 
 vals <- Merge(vals,pluses)
index <- 1
 loop(i,pmIndex)  ##add return index for pluses
 {
   PushOnEnd(returns,[i+1000,index])
   index <- index + 1
 }
  index <- 1
 vals <- Merge(vals,minuses)
 loop(i,pmIndex)  ##add return index for minuses
 {
   PushOnEnd(returns,[i+2000,index])
   index <- index + 1
 }



 Draw()
  ##Now, do a click-on loop to manage parameter updates. 
   cont <- 1
   while(cont)
   {
     resp <-   WaitForClickOnTarget(vals,returns)

    ##See if we need to edit something.
    if(resp == "quit")	
    {
      PushButton(quit,[0,0])
      cont <- 0
    }elseif(resp=="save")
    {

      PushButton(save,[0,0])

      pfile <- FileOpenOverwrite(paramsfile)

      loop(i,schemas)
      {

       value <- GetProperty(parameters,First(i))
       if(IsList(value))
       {
        ##Multi-parameter property:
       loop(j,value)
         {
          Print("saving:" + First(i)+"==" + Second(i) +"->" +j)
          FilePrint(pfile,First(i)+"*,"+j)
         }
       }else{
         Print("saving:" + First(i)+"==" + Second(i) +"->" +value)
         FilePrint(pfile,First(i)+","+value)

       }
      }

      cont <- 0

    } elseif(resp=="reset")
    {
     PushButton(reset,[0,0])
 
      pnames <- First(ts)
      defaults <- Second(ts)
      boxes <- SubList(vals,1,Length(schemas))
      loop(i,Transpose([pnames,defaults,boxes]))
      {
       SetProperty(parameters,First(i),Second(i))
       box <- Third(i)
       box.text <- Second(i)
      }
      Draw()

    }elseif(resp == "add")
    {
      Pushbutton(add,[0,0])
      #this is really like 'save' but with a new name.

      ##figure out the new name:
      if(parnamebox.text == "default")
      {
        paramsfile <- path+scriptname+".par"
      }else {
        paramsfile <- path+parnamebox.text+".par"
      }
      

      pfile <- FileOpenOverwrite(paramsfile)

      loop(i,schemas)
      {

       value <- GetProperty(parameters,First(i))
       if(IsList(value))
       {
       loop(j,value)
         {
          Print("saving:" + First(i)+"==" + Second(i) +"->" +j)
          FilePrint(pfile,First(i)+","+j)
         }
       }else{
         Print("saving:" + First(i)+"==" + Second(i) +"->" +value)
         FilePrint(pfile,First(i)+","+value)

       }
      }

    }elseif(resp == "parnamebox")
    {
        box <- parnamebox
        relx <- First(gClick) - (box.x )
        rely <- Second(gClick) - (box.y )
        cursorpos <- GetTextBoxCursorFromClick(box,relx,rely)
	box.cursorpos<-cursorpos
	Draw()
	x <- GetInput(box,"<return>",1)
	Draw()
  
    }elseif(IsList(resp))
    {
      ##plus or minus
      index <- First(resp)
      pmindex <- Second(resp)
      if(index > 2000)
      {    
         PushButton(Nth(minuses,pmindex),[0,0])
       }else{
         PushButton(Nth(pluses,pmindex),[0,0])
       }

    }  elseif(resp <= Length(schemas))
    {  ##Click and edit a parameter box:

        box <- Nth(vals,resp)
        relx <- First(gClick) - (box.x )
        rely <- Second(gClick) - (box.y )
        cursorpos <- GetTextBoxCursorFromClick(box,relx,rely)
	box.cursorpos<-cursorpos
	Draw()
	newval  <- GetInput(box,"<return>",1)
        SetProperty(parameters,First(Nth(schemas,resp)),newval)
     
    }
#   Draw()
   }
}
}


##this does a layout on the parameter grid; suitable for 
##re-layout if the number of parameters change.
##We are given schemas, a list of triplets giving parametername,
##default value, description, and parameters, an object created by
##createparameters.
##
## multi-element properties are handled in the parameters
## as a list; within schemas,
## the names have a * at the end, and the values are (potentially)
## a comma-separated list.

define LayoutPGrid(schemas,parameters,win)
{
  pFontSize <- 11  ##this is the description font size; make a bit smaller for extra room.
  rowBase <- 80


  ##we need a better estimate of the length of the rows.
  rows <- []
  loop(i,GetPropertyList(parameters))
  {
     if(SubString(i,StringLength(i),1)=="*")
     {
       PushOnEnd(rows,SplitString(GetProperty(parameters,i),","))
     }else {
       PushOnEnd(rows,GetProperty(parameters,i))
     }
  }
  rows2 <- Flatten(rows)
  rowHeight <- Min([50,Floor(((gVideoHeight-5)-rowBase)/(Length(rows2)+2))])


  c1Base <- 100
  c1 <- 150
  c2 <- 100
  c3 <- 600


  head1 <- EasyLabel("Parameter name",c1Base+c1/2,rowBase+rowHeight/2,win,18)
  head2 <- EasyLabel("Value",c1Base+c1+c2/2,rowBase+rowHeight/2,win,18)
  head3 <- EasyLabel("Description",c1Base+c1+c2+c3/2,rowBase+rowHeight/2,win,18)

  ui <- []
  vals <- []
  pluses <- []
  minuses <- []
  pmIndex <- []

  prevparname <- ""
  counter <- 1
  row <- 1
  loop(i,schemas)
  {
     parname <- First(i)
     ##is this a multi-parameter set (specified with a *)
     singlepar <- 1

     if(SubString(parname,StringLength(parname),1)=="*")
     {
         parname <- SubString(parname,1,StringLength(parname)-1)
	 singlepar <- 0

        ##Schema is multi-parameter; the default values in the schema
	##are actually separated by commas.
	pvalues <- SplitString(Second(i),",")
	
       ##use CreateParameters to make sure these are converted to numbers
       Print("pvalues:" + pvalues)
       fakeprop <- Repeat("fake",Length(pvalues))
       fakepar <- CreateParameters(Transpose([fakeprop,pvalues]),"")
       curvals <- fakepar.fake

     }else{
       curvals <- Second(i)
     }
     Print("================================")
     Print(parname )
     Print(curvals)

     #Now, curval is either a list (for multi-parameters), or a value,
     ##based on the schema file.

     ##Use the pfile value in if it exists:
     if(PropertyExists(parameters,parname))
     {
       curvals <- GetProperty(parameters,parname)
     }

     if(not IsList(curvals))
     {
       curvals <- [curvals]
     }

     ##i is the schema for the current property, which we will still use for default parameters etc.
     ##curval is the current value from the parameter file or the schema (if no parameter file exists)


      loop(curval,curvals)
      {

      if(not singlepar)
      {
       ##Add +/- button for multiple parameters.
       tmpminus <- MakeButton("-",c1Base-40,rowbase+rowheight*(row+.5),win,18)
       tmpplus <- MakeButton("+",c1Base-20,rowbase+rowheight*(row+.5),win,18)
       PushOnEnd(ui,tmpminus)
       PushOnEnd(ui,tmpplus)
       PushOnEnd(pluses,tmpPlus)
       PushOnEnd(minuses,tmpMinus)
       PushOnEnd(pmIndex,row+1)

      }


      ##Now, add the UI elements for this parameter
      	

      r1 <- EasyTextbox(First(i)+"", c1Base,rowBase + rowHeight*row,win,12,c1-2,rowHeight-2)
      r2 <- EasyTextbox(curval+"", c1Base+c1,rowBase + rowHeight*row,win,12,c2-2,rowHeight-2)
      r3 <- EasyTextbox(Third(i)+" (default: ["+Second(i)+"])", c1Base+c1+c2,rowBase + rowHeight*row,win,pFontSize,c3-2,rowHeight-2)

      PushOnEnd(ui,r1)
      PushOnEnd(ui,r2)
      PushOnEnd(ui,r3)
      PushOnEnd(vals,r2)
      row <- row+ 1
    }

  }

  return [ui,vals,pluses,minuses,pmindex]
}

define ReadSchemaFile(filename)
{
   schemalist <- FileReadList(filename)
   list <- []
   loop(i,schemalist)
    {
       line <- SplitString(i,"|")
       PushOnEnd(list,line)
    }
  return list
}



##targetlist is a set of graphical objects,
##keylist is a set of keys whose corresponding 
##value should be returned when a graphical object is clicked upon.
## This modifies the built-in waitforclickontarget so that it will
## Return the button that is clicked, along with the target, 

define WaitForButtonClickOnTarget(targetlist,keylist)
{
  
  if(not IsList(targetlist))
  { 
    SignalFatalError("First argument of WaitForClickOnTarget(targetlist,keylist) must be a list of graphical objects")
  }

  if(not IsList(keylist))
  { 
    SignalFatalError("Second argument of WaitForClickOnTarget(targetlist,keylist) must be a list")
  }
  
  if(Length(targetlist) <> Length(keylist))
  {
    SignalFatalError("Arguments of WaitForClickOnTarget(targetlist,keylist) must be the same length")
  }

  ret <- ""
  testlist <- Reverse(Transpose([targetlist,keylist]))
   
   wait1 <- 1
   while(wait1)
     {
      wait2 <- 1
      while(wait2)
       {
         pos <- WaitForMouseButton()
         if(Nth(pos,4)=="<pressed>")
          {
            wait2 <- 0
            gClick <- pos
          }
       }

      newtargs <- []
	  
      loop(i,testlist)
          {

             if(Inside(pos,First(i)))
             {
	        wait1 <- 0
                ret <- Nth(i,2)
                break
             }

          }
	  wait1 <- 0
     }
  return [ret,pos]
}

##this returns a list of actual parameter files
## in the params\ directory.
##if the params\ directory does not exist, it returns an 
##empty list.  If it does exist but no .par files are there,
##it returns '["default"]'.  Otherwise, it appends the .par
## list to ["default"]


define GetParFiles()
{  
 paramsdir <- DirListToText(gDirChain)+"params"  
 if(FileExists(paramsdir))
  {
    parfiles <- Merge(["default"],
              Second(FilterDir(GetDirectoryListing(paramsdir),
                    gDirChain,"*.par")))
  } else {
    parfiles <- []
  }

 return parfiles
}



define ListEqual(l1,l2)
{
  if(Length(l1)==Length(l2))
  {
   same <- 1


   loop(i,Transpose([l1,l2]))
    {
     if(not (First(i) == Nth(i,2)))
      {
        same <- 0
      }

    }
   } else {
     same <- 0
   } 
  return same
}



define UpdateScreenResPulldown(pd)
{

	  selected <- pd.selected
	  currentxy <- First(gScreenResInitial) +"x" + Second(gScreenResInitial)
          screenmodes <- GetVideoModes()
	  screenmodes <- SortBy(screenmodes,First(Transpose(screenmodes)))

	  ##create a list of text-based screen modes to choose from:
          modes <- []
	  loop(i, screenmodes)
	  {

	    tmp <- First(i)+"x"+Second(i)
	    if(tmp==currentxy)
	    { 
               tmp <- tmp + "*"
	    }

	     modes <- Append(modes, tmp)
	  }

	  ##Add the custom option to the end of each:
	  modes <- Append(modes,gCurrent)
	  modes <- Append(modes,gCustomText+gCustomScreenRes)

	  screenmodes <- Append(screenmodes,gCurrent)
	  screenmodes <- Append(screenmodes,gCustomText+gCustomScreenRes)


	  ##screen modes is the nested list of resolutions
	  ##modes is the text that is inside pd

	  pd.selected <- selected
	  UpdatePulldown(pd,modes)
	  pd.selected <- selected
	  return screenmodes
}
