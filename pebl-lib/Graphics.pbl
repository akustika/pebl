

## Rotozoom doesn't work right now for objects, but this rotates
## a polygon's points.  pts should be a list of [[x1,x2,x3],[y1,y2,y3]]
define RotatePoints(pts,theta)
{
   newX <- []
   newY <- []


  loop(i,Transpose(pts))
    {
      ix <- First(i)
      iy <- Nth(i,2)

	  nx <-  ix* Cos(theta) - iy * Sin(theta)
      ny <- ix * Sin(theta) + iy * Cos(theta)

      newX <- Append(newX, nx)
	  newY <- Append(newY, ny)
	  
    }

 return [newX,newY]
}


define ReflectPoints(pts)
{
   newX <- []
   newY <- []


  loop(i,Transpose(pts))
    {
      newX <- Append(newX, -First(i))
	  newY <- Append(newY, Nth(i,2))
    }

 return [newX,newY]
		
}



##
define ZoomPoints(pts,xZoom,yZoom)
{
   newX <- []
   newY <- []


  loop(i,Transpose(pts))
    {
      ix <- First(i)
      iy <- Nth(i,2)

	  nx <-  ix* xZoom
      ny <- iy * yZoom

      newX <- Append(newX, nx)
	  newY <- Append(newY, ny)
	  
    }

 return [newX,newY]
}







define Plus(x,y,size, width, color)
{
   x1 <- x-size
   x2 <- x-width/2
   x3 <- x+width/2
   x4 <- x+size

   y1 <- y-size
   y2 <- y-width/2
   y3 <- y+width/2
   y4 <- y+size

   xs <- [x1,x1,x2,x2,x3,x3,x4,x4,x3,x3,x2,x2]
   ys <- [y3,y2,y2,y1,y1,y2,y2,y3,y3,y4,y4,y3]
   x <- Polygon(x,y,xs,ys,color,1)
   return x
}


## Makes a block E object in a particular direction (1-4).
## 1 is pointing right;
## 2 is pointing down;
## 3 is pointing left;
## p is pointing up

define BlockE(x,y,h,w,thick,dir,color)
{

  if(dir == 1 or dir==2)
{
  xo <- 1
} else{
  xo <- -1
}
 
  if(dir == 1 or dir == 3)
  {
     abase <- x
     bbase <- y
  } else {

     abase <- y
     bbase <- x
  }


	a1 <- abase + xo*(-1)*w/2
    a2 <- abase+  xo*w/2
	a3 <- a1+ xo*thick
	a4 <- a2
	

	b1 <- bbase-h/2
    b2 <- bbase+h/2
    b3 <- b1+thick
    b4 <- b2-thick
    b5 <- bbase-thick/2
    b6 <- bbase+thick/2
 
   as <- [a1,a1,a2,a2,a3,a3,a4,a4,a3,a3,a2,a2]
   bs <- [b1,b2,b2,b4,b4,b6,b6,b5,b5,b3,b3,b1]
   if(dir ==1 or dir==3)
     { 
       p <- Polygon(x,y,as,bs,color,1)
     }else{
	   p <- Polygon(x,y,bs,as,color,1)
     }
   return p
}





define MakeStarPoints (radiusOuter, radiusInner, num)
{
   pointsX <- []              
   pointsY <- []              
   s <-   Sequence(1,num,1)
   arc <- 2 * 3.14159 / num

   loop(i,s)
   {
     pointsX <- Append(pointsX,Cos(i*arc)*radiusOuter)
     pointsY <- Append(pointsY,Sin(i*arc)*radiusOuter)
              
     pointsX <- Append(pointsX,Cos((i+.5)*arc )*radiusInner)
     pointsY <- Append(pointsY,Sin((i+.5)*arc )*radiusInner)

   }


    pointsX <- Append(pointsX,Cos(arc)*radiusOuter)
    pointsY <- Append(pointsY,Sin(arc)*radiusOuter)

   return  [pointsX,pointsY]
}




define MakeNGonPoints (radius, num)
{
   pointsX <- []              
   pointsY <- []              
   s <-   Sequence(1,num,1)
   arc <- 2 * 3.14159 / num

   loop(i,s)
   {
     pointsX <- Append(pointsX,Cos(i*arc)*radius)
     pointsY <- Append(pointsY,Sin(i*arc)*radius)

   }


    pointsX <- Append(pointsX,Cos(arc)*radius)
    pointsY <- Append(pointsY,Sin(arc)*radius)

   return  [pointsX,pointsY]
}




define RGBtoHSV(a)
{
  if(not IsColor(a))
   {
    SignalFatalError("RGBtoHSV(<color>) must take a color object as an argument.") 
   }
   min <- Min([a.red,a.green,a.blue])
   max <- Max([a.red,a.green,a.blue])

   if(min==max)
   {
      h <- 0
      s <- 0
   }elseif(max==a.red)
   {
      h <- Mod(60 * (a.green-a.blue)/(max-min),360)
   }elseif(max == a.green)
   {
      h <-  60 * (a.blue-a.red)/(max-min) + 120
   } else {
      h <- 60 * (a.red-a.green)/(max-min)+240
   }

   if(max==0)
    {
       s <- 0
    }else{
       s <- (max-min)/max
    }

   v<-max
  return [h,s,v]
}



define ThickLine(x1,y1,x2,y2,size,color)
{

  ##Makes a 'thick' line

  midx <- (x1+x2)/2
  midy <- (y1+y2)/2

  dx1 <- x1 - midx
  dx2 <- x2 - midx
  dy1 <- y1 - midy
  dy2 <- y2 - midy 

  ##Compute line slope.
  angle <- GetAngle((x2-x1),(y2-y1))
  
  tan1 <- DegToRad(Mod(360+angle+90,360))
  tan2 <- DegToRad(Mod(360+ angle-90,360))

  
  #get new '1' points.
  x1a <- dx1 + size/2 * Cos(tan1)
  x1b <- dx1 + size/2 * Cos(tan2)
  y1a <- dy1 + size/2 * Sin(tan1)
  y1b <- dy1 + size/2 * Sin(tan2)

  x2a <- dx2 + size/2 * Cos(tan1)
  x2b <- dx2 + size/2 * Cos(tan2)
  y2a <- dy2 + size/2 * Sin(tan1)
  y2b <- dy2 + size/2 * Sin(tan2)

  xs <- [x1a,x1b,x2b,x2a]
  ys <- [y1a,y1b,y2b,y2a]

  return Polygon(midx,midy, xs,ys,color,1)
}



##Gets an angle, in degrees, of an X,Y vector
define GetAngle(dx, dy)
{

  baseangle <- RadToDeg(ATan(dy/dx))
  
  ##Ultimate angle depends on the quadrant, if you use ATN
  if(dx >=0 and dy >= 0)  ##1st quadrant
   {
       ret <- baseangle
   } elseif(dx<0 and dy>= 0) {         ##2nd quadrant
       ret <- 180+baseangle 
   } elseif(dx<0 and dy<0) {          ##3rd quadrant
       ret <- 180+baseangle
   } else {                           ##4th quadrant
       ret <- 360+baseangle
   }

   return Mod(ret,360)
}




## This is a simple hack to 'reset' the canvas; blanking
## anything that had been blitted to it.

define ResetCanvas(canvas)
{
 if(not IsCanvas(canvas))
    {
	  SignalFatalError("argument <canvas> in ResetCanvas(<canvas>) was not a canvas but " + canvas)
    }
  canvas.bgcolor <- canvas.bgcolor
}


##
define MakeAttneave(radius,numpoints,minangle, maxangle)
{

  ##First, sample numpoints xy points
  pts <- []
  num <- 0
  

 while( num < numpoints)
   {
    num <- num + 1
    #Use sampling-and-reject to get points within a circle
    tryX <- Round((Random()-.5)*radius)
    tryY <- Round((Random()-.5)*radius)

    while(Sqrt(tryX^2 + tryY^2) > radius)
    {
      tryX <- Round((Random()-.5)*radius)
      tryY <- Round((Random()-.5)*radius)
    }

   ##Add the point
   pts <- Append(pts,[tryX,tryY,num])

  }


   ##make the hull
   hull <- Rest(ConvexHull(pts))
 

   hullIDs <- Third(Transpose(hull))

 
   rem <- Shuffle(Removesubset(pts,hullIDs))
   
 
   #Now, iteratively add each point in rem to the point which
   #add the least to the polygon.
   bad <- []   
   remlen <- Length(rem)+1
   ##If the remander is not empty and shrinking, keep going.
   while(Length(rem)>0 and Length(rem) <remlen)
    {

     loop(i,rem)
      {
	    length <- Length(hull)
        hull <- InsertAttneavePointRandom(hull,i,minangle, maxangle)
     	##Keep any points not added to the hull for later.
        if(Length(hull)==length)
         {
           bad <- Append(bad,i)
         }
      }
     rem <- bad
     remlen <- Length(rem)
    }

   ##If it is bad, recurse

   test <- ValidateAttneaveShape(hull,minangle,maxangle)

   if(Length(rem)>0 or test==0)
   {
      hull <-  MakeAttneave(radius,numpoints,minangle, maxangle)
   }

  return hull
}


## compute convex hull through Jarvis 'gift-wrapping' algorithm
##
define ConvexHull(pts)
{
  ##add a set of indexes to the points.

#  pts <- (Transpose(Append(Transpose(pts), Sequence(1,Length(pts),1))))



  #reorder based on X coordinate.  The first & last point will
  #be on the hull.  The last one is easier to use.


  pts <- SortBy(pts,First(Transpose(pts)))

  n <- Length(pts)
  cur <- Nth(pts,n)
  hull <- [cur]
  hullIDS <- [n]
  nextID <- -1

  
  ##Keep going until you get #1 again.
  while(nextID != Length(pts))
  {

    pts <- RemoveSubset(pts,[nextID])

    next <- First(pts)
    nextID <- 1

   j <- 1
   loop(i,pts)
   {
   ##check to see if any point is better

   x <- ToRight(cur,next,i)

   if(ToRight(cur,next,i) < 0)
     {

      next <- i
      nextID <- j
     }

     j <- j + 1
   }

   ##Now, next is the rightmost point is determined.
   ##we can probably trim out the selected point from pts here
    ##update the basic current/next
    hull <- Append(hull,next) 
    hullIDs <- Append(hullIDs,nextID)#not correct
    cur <- next  #Update to the current 

  }

 return hull
}

## This inserts the point at a random location, as long as it does not
## cross any other edges.
define InsertAttneavePointRandom(path, point,minangle,maxangle)
{

   ##Try to insert point into path at each of these 
   ##locations.  Use the first one that works.
   rotations <- Shuffle(Sequence(1,Length(path),1))

   loop(try, rotations)
   {

     path2 <- Rotate(path,try)

     xx <- gHomeX
     yy <- gHomeY
   
     #try inserting at the beginning of the path
	 prev <- Second(path2)
     a <-First(path2)
	 b <- Nth(path2,Length(path2))
	 next <- Nth(path2,Length(path2)-1)

	 ## first check if it will create any vertices whose angles are
     ##  out of bounds


	 anglea <- RadToDeg(GetAngle3(prev,a,point))
	 angleb <- RadToDeg(GetAngle3(a,point,b))
	 anglec <- RadToDeg(GetAngle3(point,b,next))
	


	 if(anglea > minangle and angleb > minangle and anglec > minangle and
 	    anglea < maxangle and angleb < maxangle and anglec < maxangle)
       {

          intersects <- 0
       } else {

          intersects <- 1
       }
   

     #If its inserted between a and b, there are two
     #segments pa and pb.  Check if pa or pb intersect any
     #of the line segments in the path. 

     paired <- Transpose([path2, Rotate(path2,1)])


     pairs1 <- SubList(paired,2,Length(paired)-1)
     pairs2 <- SubList(paired,1,Length(paired)-2)




     loop(pair, pairs1)
      {

	   ps1  <- First(pair)	 
       ps2  <- Second(pair)

      intA <-  SegmentsIntersect(First(point),Second(point),First(a),Second(a),
                         First(ps1),Second(ps1),First(ps2),Second(ps2))



       intersects <- intersects or intA 
      }
     loop(pair, pairs2)
      {

	   ps1  <- First(pair)	 
       ps2  <- Second(pair)
       intB <-  SegmentsIntersect(First(point),Second(point),First(b),Second(b),
                         First(ps1),Second(ps1),First(ps2),Second(ps2))
						 

 
       intersects <- intersects or intB
      }



    
   ##we went through all the segments

   if(not intersects)
    {
      break
    }
    
  }

   path <- Insert(path, point,try)
   return   path
}



##gets angle abc by law of cosines
define GetAngle3(a,b,c)
{
   ax <- First(a); ay <- Second(a)
   bx <- First(b); by <- Second(b)
   cx <- First(c); cy <- Second(c)
	
   sidea <- Sqrt((bx - cx)^2 + (by - cy)^2)
   sideb <- Sqrt((ax - cx)^2 + (ay - cy)^2)
   sidec <- Sqrt((ax - bx)^2 + (ay - by)^2)

  angle <-  ACos((sideb^2 - sidea^2 - sidec^2) / (-2*sidea * sidec))

  return angle
}

## Determines whether c is 'to the right' of a,b, essentially by 
## computing the determinant.
define ToRight(p1,p2,p3)
{
  a <- First(p1)
  d <- Second(p1)
  b <-First(p2)
  e <-Second(p2)
  c <- First(p3)
  f <- Second(p3)

 tmp <- (a*e -a*f + b*f-b*d+c*d-c*e)


  if(tmp >     0.0000000001)
  {
   ret <- 1
  } elseif(tmp< - 0.0000000001)
  {
   ret <- -1
  } else {
   ret <- 0
  }

 return ret
}


define SegmentsIntersect(x1,y1,x2,y2, a1,b1,a2,b2)
{
    dx <- x2 - x1
    dy <- y2 - y1
    da <- a2 - a1
    db <- b2 - b1

    #Lines are parallel
    if((da * dy - db * dx) == 0 )
        {
            intersect <- 0         

        } else {

        #parameterize the two vectors.   
        s <- (dx * (b1 - y1) + dy * (x1 - a1)) / (da * dy - db *  dx)
        t <- (da * (y1 - b1) + db * (a1 - x1)) / (db * dx - da *  dy)
        #Don't count intersections at just one edge: 
        intersect <- (s>0.0001) and (s < .9999) and (t > 0.0001) and (t < .9999)
        }

   #    point of intersection is: (x1 + t * dx, y1 + t * dy)
  
return intersect
}



define ValidateAttneaveShape(shape,minAngle,maxAngle)
{



  angles <- Transpose([Rotate(shape,-1), shape, Rotate(shape,1)])
  good <- 1
  loop(i, angles)
  {
   angle <- RadToDeg(GetAngle3(First(i),Second(i),Third(i)))

   if(not(angle > minAngle and angle < maxangle))
    {
     good <- 0
    }
  }

  if(good)
  {
   edges <- angles
   loop(i,Sequence(1,Length(shape)-1,1))
   {


	  testedge <- First(edges)
      t1 <- First(testedge)
      t2 <- Second(testedge)
	  a1 <-First(t1)
      b1 <- Second(t1)
      a2 <- First(t2)
      b2 <- Second(t2)

      edges <- SubList(edges,2,Length(edges))
      loop(edge , edges)
      {
	      p1 <- First(edge)
	      p2 <- Second(edge)
          x1 <- First(p1)
          y1 <- Second(p1)
          x2 <- First(p2)
          y2 <- Second(p2)
         
	     if(SegmentsIntersect(x1,y1,x2,y2, a1,b1,a2,b2))
          {
              good <- 0
          }

       if(good == 0)
       {
        break 
       }

      }

    if(good == 0)
     {
      break 
     }

   }
  }
  return good
}


