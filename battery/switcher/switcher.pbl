define Start(p)
{

   gCols <- [MakeColor("red"),MakeColor("blue"),MakeColor("yellow"), MakeColor("darkgreen"),MakeColor("grey"),MakeColor("orange")]
   gStim <- FileReadList("Uppercase.txt")
   gFont <- MakeFont(gPEBLBaseFont,0,22,MakeColor("black"),MakeColor("black"),0)
   gWin <- MakeWindow("black")

   trial <- Transpose([[1,1,2,2,3,3,4,4,5,5],
                      [1,2,2,3,3,4,4,5,5,6]])

    Trial(trial)
    Trial(trial)
    Trial(trial)

}





define Trial(setup)
{

  circs <- []
  texts <- []

   points <- NonOverlapLayout(100,gVideoWidth-100,100,gVideoHeight-100,60,10)
   stim <- PasteTables(setup,points)
   labels <- SampleN(gStim,6)

     back <- Circle(First(First(points)),Second(First(points)),35,MakeColor("white"),1)
     AddObject(back,gWin)

      loop(i,stim)
       {
          color <- Nth(gCols,First(i))

          label <- Nth(labels,Second(i))+""
          x <- Third(i)
          y <- Fourth(i)

          p1 <- Circle(x,y,30,color,1)
          t <- MakeLabel(label,gFont)
          Move(t,x,y)
          AddObject(p1,gWin)
          AddObject(t,gWin)
         
          texts <- Append(texts,t)
          circs <- Append(circs,p1)

       }
   Draw()

   ids <- Sequence(1,10,1)

   resp <- 0
   next <- 1
   done <- 0
   while(not done)
   {
     resp <- WaitForClickOnTarget(circs,ids)
     if(resp == next)
     { 
        next <- next + 1
  
        Move(back,Third(First(stim)),Fourth(First(stim)))
        Draw()
        stim <- Rotate(stim,1)
        Print("Correct")       
     }else{
       Print("wrong")
    }
     if(next > 10)
      {
        done <- 1
      }


   }
}

define PasteTables(tab1,tab2)
{
   a <- Transpose(tab1)
   b <- Transpose(tab2)

   return Transpose(Merge(a,b))
}


define NonOverlapLayout(xmin, xmax, ymin, ymax, tol, num)
{

   ##should you watch the points evolve?
   watch <- 0
   

   ##Note that it is possible to arrange the situation 
   ## so that the distribution will never be satisfied.  So, lets
   ## set up a 'limit' at which point we give up and return the best
   ## we have so far.

   limit <- 100
 

  ## First, just initialize num points.
  pts <- []
  i <- 1
  while(i <= num)
   {

     x <- xmin + Random()*(xmax-xmin)
     y <- ymin + Random()*(ymax-ymin)
     pts <- Append(pts, [x,y])
     i <- i + 1
   }

  #Now, check for the minimum distance between two points.
   tries <- 1
   minpair <-  GetMinDist(pts)


   ##Move one point at a time
   while(First(minpair) < tol and tries < limit)
   {

     pt1id <- Nth(minpair,2)
     pt2id <- Nth(minpair,3)

	
     pt1 <- Nth(pts,pt1id)
     pt2 <- Nth(pts,pt2id)


    #resample the 'bad' points

     ##Half the time, try to move a little bit away from 
     ##the closest. Otherwise, do it randomly.

     if(0)
     {

       ##This doesn't seem to work.
       lastpt <- pt1       
       pt1 <- [-1,-1]
       while((First(lastpt) > xmin) and (First(lastpt)<xmax) and 
              (Second(lastpt) > ymin) and (Second(lastpt)<ymax))
         {
           #Resampling
           dist <- Random() * tol
           diff <- [First(pt2) - First(pt1),Second(pt2)-Second(pt1)]     
           pt1 <- VecSum(pt2,VecTimes(diff,[dist,dist]))
           if(watch)
           {
		     Print("watch this")
           }
         }

        


     } else{
 
     pt1 <-   [ xmin + Random()*(xmax-xmin),
                  ymin + Random()*(ymax-ymin) ]

    }
   #   pt2 <-   [ xmin + Random()*(xmax-xmin),
   #                ymin + Random()*(ymax-ymin) ]


     ##Reassemble pts
     tmp <- RemoveSubset(pts,[pt1id])

     ##See if this configuration is an improvement
     testpts <- Merge(tmp,[pt1])
     minpairtest <-  GetMinDist(testpts)

     ##If we've made an improvement, use it, otherwise abandon it.
     if(First(minpairtest) >= First(minpair))
     {
        minpair <- minpairtest
        pts <- testpts
     }
     tries <- tries + 1

  
   }


  
  return Shuffle(pts)
}


define GetMinDist(pts)
{
   len <- Length(pts)
   index1 <- 1
   mindist <- Dist(First(pts),Nth(pts,2))
   id1 <- 1
   id2 <- 2
 
   loop(i,pts)
   {
     pt1 <- i
     index2 <- index1 + 1
 

     if(index2 <= len)
      {
      rest <- SubList(pts,index2, Length(pts))
      loop(j, rest)
       { 
        d <- Dist(i,j)

        if(d < mindist)
        {
          mindist <- d
          id1 <- index1
          id2 <- index2
        }

        index2 <- index2 + 1
      }
      }
     index1  <- index1 + 1
   }

   return [mindist,id1,id2]
}

define VecTimes(a,b)
{
   tmp <- Transpose([a,b])
   out <- []
   loop(i,tmp)
   {
     out <- Append(out, First(i) * Nth(i,2))
   }
  return out
}

define VecSum(a,b)
{
   tmp <- Transpose([a,b])
   out <- []
   loop(i,tmp)
   {
     out <- Append(out, First(i) + Nth(i,2))
   }
  return out
}



##  This function takes a list of anything, and a list of indexes
##  specifying the items to extract from the list.  The indexes can
##  be in any order, but the extracted list will be in the order 
##  of the original list.  Items that are not numbers less than or 
##  equal to the length of the list will be ignored.
define RemoveSubset(list, items)
{
   #Check the arguments to insure they are the proper type
    if(not IsList(list))
	{
	    SignalFatalError("First argument of function [RemoveSubset(<list>,<list>)] is not a list")
	}
    if(not IsList(items))
	{
	    SignalFatalError("First argument of function [RemoveSubset(<list>,<list>)] is not a list")
	}


    returnList <- []      #Make an initial blank list to return
    index <- 1            #keep track of the index
    loop(i, list)
    {
	#If the index is in the items list, add it to the return list
	if(not IsMember(index, items))
	{
	    returnList <- Append(returnList, i)
	}
	index <- index + 1
    }

    return returnList
}
