define Start(p)
{

#   gCols <- [MakeColor("red"),MakeColor("darkblue"),MakeColor("yellow"),MakeColor("grey"),MakeColor("darkgreen")]

   ##Number of clicks per trial.
   triallength <- 12
   
   ##These should be basically color-blind safe:
   gCols <- [MakeColorRGB(230,159,0),  #orange
   	    MakeColorRGB(86,180,233),  #skyblue
	    MakeColorRGB(0,158,115),   #blue-green
      	    MakeColorRGB(240,228,66),  #yellow
	    MakeColorRGB(213,94,0)]   #vermillion (red)

   gStim <- FileReadList("Uppercase.txt")
   gFont <- MakeFont(gPEBLBaseFont,0,22,MakeColor("black"),MakeColor("black"),0)
   gWin <- MakeWindow("black")
   gSleepEasy <- 1

   gSubNum <- GetSubNum(gWin)
   gFileOut <- FileOpenAppend("switch-"+gSubNum+".csv")
   
   coltmplt <-   [1,1,2,2,3,3,4,4,5,5]
   numtmplt <-   [1,2,3,4,5,1,2,3,4,5]
   shapetmplt <- [1,2,1,3,2,4,3,5,4,5]
   FilePrint(gFileOut,"gSubNum,timestamp,testtype,numcues,numerr,tooslow,waittime,perftime,medtime")   

################################################################
## Instructions:

 gInst <- EasyTextBox("",50,50,gWin,18,gVideoWidth-100,200)
 gInst.text <- "In this test, you will see a screen with colored shapes like you see below.  Each shape will have a letter on it.  One shape will be circled.  When you click the mouse to begin, a 'match rule' will be shown at the top.  You can click now to see this. It will read 'COLOR'.  This tells you that you need to find the symbol that matches the color of the currently circled symbol.  When you find it, the circle will jump to the next spot, and you will see a new rule at the top. In this example, it will be LETTER, so find the shape with the matching letter. Try this screen for practice."


   gLeft <- 150
   gRight <- gVideoWidth-gLeft
   gUpper <- 350
   gLower <- gVideoHeight-50


  Draw()
  Trial(Transpose([coltmplt,numtmplt,shapetmplt]),[1,2,3,1,2,3])


 
   gInst.text <- "Great. In the first three trials, there will be only two rules, and the rules will alternate between the two rules.  Press any key to begin."
  Draw()
   gLeft <- 150
   gRight <- gVideoWidth-gLeft
   gUpper <- 100
   gLower <- gVideoHeight-gUpper 

  WaitFordownClick()
  Hide(gInst)
  Draw()


    i <- 1


    ##Consistent 2 rule
    type <- 1
    cuebase <- Shuffle([[1,2],[2,3],[1,3]])
    loop(base,cuebase)
     {

      seq <- Sequence(1,5,1)
      tmpcol <- Shuffle(seq)
      tmpnum <- Shuffle(seq)
      tmpshape <- Shuffle(seq)

      trial <- Shuffle(Transpose([Replace(coltmplt,Transpose([seq,tmpcol])),
	          Replace(numtmplt,Transpose([seq,tmpnum])),
              Replace(shapetmplt,Transpose([seq,tmpshape]))]))

      cues <-SubList(RepeatList(base,Ceiling(triallength/2)),1,trialLength)

      time <- GetTime()
      ret  <- Trial(trial,cues)

      waittime <- Third(ret)
      perftime <- Fourth(ret)
      medtime <- Fifth(ret)
      tooslow <- Nth(ret,6)

     x <- FilePrint(gFileOut,gSubNum + "," + TimeStamp()+ ","+ type + "," +
                First(ret) + "," + Second(ret) +","+ tooslow +","+waittime + 
                ","+perftime+","+medtime)



      i <- i + 1

    }

    gInst.text <- "Now, for three trials, you will alternate between all three rules, but in a consistent order.  Try to remember the order of the rules, so you can anticipate them and not have to refer to the rule cue.  Click mouse to begin."
    Show(gInst)
    Draw()
    WaitForDownCLick()
    Draw()
    Hide(gInst)
    Draw()
    ##Consistent order-3 rule
    type <- 2
    threes <- [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
    cuebase <- SampleN(threes,3)
    loop(base,cuebase)
     {

      seq <- Sequence(1,5,1)
      tmpcol <- Shuffle(seq)
      tmpnum <- Shuffle(seq)
      tmpshape <- Shuffle(seq)

      trial <- Shuffle(Transpose([Replace(coltmplt,Transpose([seq,tmpcol])),
   	               Replace(numtmplt,Transpose([seq,tmpnum])),
                       Replace(shapetmplt,Transpose([seq,tmpshape]))]))

      cues <-SubList(RepeatList(base,Ceiling(trialLength/3)),1,trialLength)

      time <- GetTime()
      ret  <- Trial(trial,cues)

      waittime <- Third(ret)
      perftime <- Fourth(ret)
      medtime <- Fifth(ret)
      tooslow <- Nth(ret,6)

     x <- FilePrint(gFileOut,gSubNum + "," + TimeStamp()+ ","+ type + "," +
                First(ret) + "," + Second(ret) +","+ tooslow +","+waittime + 
                ","+perftime+","+medtime)

     Print(x)
    
   i <- i + 1

    }

    gInst.text <- "Now you will alternate between all three rules, but in a random order.  Click mouse to begin."
    Show(gInst)
    Draw()
    WaitForDownCLick()
    Draw()
    Hide(gInst)
    Draw()
    ##Random order-3 rule
    type <- 3
    times <- [1,2,3]
    loop(x,times)
     {

      seq <- Sequence(1,5,1)
      tmpcol <- Shuffle(seq)
      tmpnum <- Shuffle(seq)
      tmpshape <- Shuffle(seq)

      trial <- Shuffle(Transpose([Replace(coltmplt,Transpose([seq,tmpcol])),
	          Replace(numtmplt,Transpose([seq,tmpnum])),
              Replace(shapetmplt,Transpose([seq,tmpshape]))]))


      cues <- SubList(ShuffleEpoch([1,2,3],
                          Ceiling(trialLength/3)),1,trialLength)

      time <- GetTime()
      ret  <- Trial(trial,cues)

      waittime <- Third(ret)
      perftime <- Fourth(ret)
      medtime <- Fifth(ret)
      tooslow <- Nth(ret,6)
      FilePrint(gFileOut,gSubNum + "," + TimeStamp()+ ","+ type + "," +
                First(ret) + "," + Second(ret) +","+ tooslow +","+waittime + 
                ","+perftime+","+medtime)
     
      i <- i + 1

    }

   Print(GetTime()/1000/60)
   Print(TimeStamp())

}


define Trial(setup,cues)
{



  cue <- EasyLabel("Click here to begin",gVideoWidth/2,20,gWin,44)

  circs <- []
  texts <- []
  backs <- []
  rts <- [] ##list of correct response times.
   tooslow <- 0
   cor <- 0
   inc <- 0
   first <- -1

   black <- MakeColor("black")
   points <- NonOverlapLayout(gLeft,gRight,gUpper,glower,80,10)
   stim <- PasteTables(setup,points)
   stim <- PasteTables(stim,Transpose([Sequence(1,10,1)]))
   labels <- SampleN(gStim,6)

     back <- Circle(First(First(points)),Second(First(points)),40,MakeColor("white"),1)
     AddObject(back,gWin)

      loop(i,stim)
       {
          color <- Nth(gCols,First(i))
          label <- Nth(labels,Second(i))+""

          x <- Fourth(i)
          y <- Fifth(i)
          p1 <- GetShape(Third(i),x,y,color)
          pback <- Circle(x,y,35,black,1)
          t <- MakeLabel(label,gFont)
          Move(t,x,y)

          AddObject(pback,gWin)
          AddObject(p1,gWin)
          AddObject(t,gWin)
         
          backs <- Append(backs,pBack)
          texts <- Append(texts,t)
          circs <- Append(circs,p1)

       }
   Draw()
   t0 <- GetTime()

   ids <- Sequence(1,10,1)

   labels <- ["Color","Letter","Shape"]
   resp <- First(stim)
   next <- 1
   done <- 0

   WaitForClickOnTarget([cue],[1])

   t1 <- GetTime()
   lasttime <- t1
   Draw()
   loop(rule,cues)
   {


     curid <- Nth(resp,6)
     currentval <- Nth(resp,rule)
	 cue.text <- Nth(labels,rule)
     Draw()

     cont <- 1
     while(cont)
      {
       respa <- WaitForClickOnTarget(backs,stim)
       time <- GetTime()
       ##resp is the clicked-on stim string.

     if(Nth(respa,rule) == currentval and 
         Nth(respa,6) <> curid)
      { 
    ###Correct
        rt <- (time-lasttime)
        rts <- Append(rts, rt)
        tooslow <- tooslow + (rt > 2000)
        lasttime <- time    
        resp <- respa  
        Move(back,Fourth(resp),Fifth(resp))
        Draw()
        cont <- 0
#        Print("Correct")       
        cor <- cor + 1
		if(first<0)
         {
           first <- GetTime()
         }
     }else{
       inc <- inc + 1 
#       Print("wrong")
      }
     }

   }
  tend <- time

  Print(rts)
  return [cor,inc,(t1-t0),(tend-t1),Median(rts),tooslow]
}

define PasteTables(tab1,tab2)
{

   a <- Transpose(tab1)
   b <- Transpose(tab2)


   return Transpose(Merge(a,b))
}


define NonOverlapLayout(xmin, xmax, ymin, ymax, tol, num)
{

   ##should you watch the points evolve?
   watch <- 0
   

   ##Note that it is possible to arrange the situation 
   ## so that the distribution will never be satisfied.  So, lets
   ## set up a 'limit' at which point we give up and return the best
   ## we have so far.

   limit <- 100
 

  ## First, just initialize num points.
  pts <- []
  i <- 1
  while(i <= num)
   {

     x <- xmin + Random()*(xmax-xmin)
     y <- ymin + Random()*(ymax-ymin)
     pts <- Append(pts, [x,y])
     i <- i + 1
   }

  #Now, check for the minimum distance between two points.
   tries <- 1
   minpair <-  GetMinDist(pts)


   ##Move one point at a time
   while(First(minpair) < tol and tries < limit)
   {

     pt1id <- Nth(minpair,2)
     pt2id <- Nth(minpair,3)

	
     pt1 <- Nth(pts,pt1id)
     pt2 <- Nth(pts,pt2id)


    #resample the 'bad' points

     ##Half the time, try to move a little bit away from 
     ##the closest. Otherwise, do it randomly.

     if(0)
     {

       ##This doesn't seem to work.
       lastpt <- pt1       
       pt1 <- [-1,-1]
       while((First(lastpt) > xmin) and (First(lastpt)<xmax) and 
              (Second(lastpt) > ymin) and (Second(lastpt)<ymax))
         {
           #Resampling
           dist <- Random() * tol
           diff <- [First(pt2) - First(pt1),Second(pt2)-Second(pt1)]     
           pt1 <- VecSum(pt2,VecTimes(diff,[dist,dist]))
           if(watch)
           {
		     Print("watch this")
           }
         }

        


     } else{
 
     pt1 <-   [ xmin + Random()*(xmax-xmin),
                  ymin + Random()*(ymax-ymin) ]

    }
   #   pt2 <-   [ xmin + Random()*(xmax-xmin),
   #                ymin + Random()*(ymax-ymin) ]


     ##Reassemble pts
     tmp <- RemoveSubset(pts,[pt1id])

     ##See if this configuration is an improvement
     testpts <- Merge(tmp,[pt1])
     minpairtest <-  GetMinDist(testpts)

     ##If we've made an improvement, use it, otherwise abandon it.
     if(First(minpairtest) >= First(minpair))
     {
        minpair <- minpairtest
        pts <- testpts
     }
     tries <- tries + 1

  
   }


  
  return Shuffle(pts)
}


define GetMinDist(pts)
{
   len <- Length(pts)
   index1 <- 1
   mindist <- Dist(First(pts),Nth(pts,2))
   id1 <- 1
   id2 <- 2
 
   loop(i,pts)
   {
     pt1 <- i
     index2 <- index1 + 1
 

     if(index2 <= len)
      {
      rest <- SubList(pts,index2, Length(pts))
      loop(j, rest)
       { 
        d <- Dist(i,j)

        if(d < mindist)
        {
          mindist <- d
          id1 <- index1
          id2 <- index2
        }

        index2 <- index2 + 1
      }
      }
     index1  <- index1 + 1
   }

   return [mindist,id1,id2]
}

define VecTimes(a,b)
{
   tmp <- Transpose([a,b])
   out <- []
   loop(i,tmp)
   {
     out <- Append(out, First(i) * Nth(i,2))
   }
  return out
}

define VecSum(a,b)
{
   tmp <- Transpose([a,b])
   out <- []
   loop(i,tmp)
   {
     out <- Append(out, First(i) + Nth(i,2))
   }
  return out
}


define GetShape(type,x,y,color)
{
    if(type==1)
     {
         shape <- Circle(x,y,30,color,1)
     }elseif(type==2)
    {
        shape <- Square(x,y,45,color,1)
    } elseif(type==3)
    {

      shape <- Plus(0,0,30,20,color)
      Move(shape,x,y)

   } elseif(type==4)
   {
       shape <- Ellipse(x,y,30,22,color,1)
		
   } elseif(type==5)
   {
       pts <- MakeStarPoints(30,20,7)
       shape <- Polygon(x,y,First(pts),Second(pts),color,1)

   }else{
    SignalFatalError("Unknown shape type in GetShape.")
   }
  return shape
}



##  This function takes a list of anything, and a list of indexes
##  specifying the items to extract from the list.  The indexes can
##  be in any order, but the extracted list will be in the order 
##  of the original list.  Items that are not numbers less than or 
##  equal to the length of the list will be ignored.
define RemoveSubset(list, items)
{
   #Check the arguments to insure they are the proper type
    if(not IsList(list))
	{
	    SignalFatalError("First argument of function [RemoveSubset(<list>,<list>)] is not a list")
	}
    if(not IsList(items))
	{
	    SignalFatalError("First argument of function [RemoveSubset(<list>,<list>)] is not a list")
	}


    returnList <- []      #Make an initial blank list to return
    index <- 1            #keep track of the index
    loop(i, list)
    {
	#If the index is in the items list, add it to the return list
	if(not IsMember(index, items))
	{
	    returnList <- Append(returnList, i)
	}
	index <- index + 1
    }

    return returnList
}


define ShuffleEpoch(list,times)
{
   out <- Shuffle(list)
   i <-1
   next <- First(list)
   try <- out
   while(i < times)
   {
    try <- Shuffle(list)    
    while(First(try)==First(out))
    {

      try <- Shuffle(list)    
    }


     out <- Merge(Reverse(try),out)

    i <- i + 1
   }
  return out
}
