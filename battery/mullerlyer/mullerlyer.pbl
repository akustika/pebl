##  PEBL Test Battery: Muller-Lyer illusion
##  
##  This test uses an adaptive design to find a point of 
##  ambivalence between the two figures in a Muller-Lyer 
##  illusion.
## 
##  Released 2011 Shane T. Mueller, Ph.D smueller@obereed.net
##  To cite:
##  Mueller, S. T. (2011).  The PEBL Muller-Lyer Illusion Test. 
##      Computer Software downloaded from http://pebl.sf.net.
##
## 

define Start(p)
{

  prestime <- 500         ##how long to do the presentation, in ms
  trials <- 50            ##Number of trials
  spread <- 125           ##How many pixels left and right of the centerline will the stimuli be

  gWin <- MakeWindow("black")

  if(gSubNum==0)
   {
     gSubNum <- GetSubNum(gWin)
   }

  gSleepEasy <- 1
  ShowCursor(0)

  inst <- EasyTextBox("In this study, you will see pairs of figure, like are shown on the bottom.  You will be asked which side has the longer line.  You should ignore the arrows on the ends, and look just at the line.  In the example below, the lines are actually the same length. There will be a total of "+trials+ " comparisons to make.  Make your decision as quickly and and accurately as possible.  You will make your response by hitting the left and right shift keys.  Press any key to begin.", 10,10,gWin,15,gVideoWidth-20,120)
  
 
    line1 <- MakeMLStim(gVideoWidth/2-spread,gVideoHeight/2+30,120,50,100)
    line2 <- MakeMLStim(gVideoWidth/2+spread,gVideoHeight/2+30,120,50,80)
   
     AddComplex(line1,gWin)
     AddComplex(line2,gWin)
     Draw()
     WaitForAnyKEyPress() 
     RemoveComplex(line1,gWin)
     RemoveComplex(line2,gWin)
	 Hide(inst,gWin)
  fileout <- FileOpenAppend("mullerlyer-"+gSubNum+".csv")
  header <- EasyLabel("which is longer?",gVideoWidth/2,20,gWin,22)
  footer <- EasyLabel("<lshift>                 <rshift>",gVideoWidth/2,gVideoHeight-40,gWin,22)



   diff <- 0    ##start diff value.
   ##Use a jittered staircase method to find point of indifference.
   trial <- 1
   while(trial<=trials)
   {

     ##determine difference between the two; +/-

     l1 <- 190 + Random() * 40
     l2 <- l1 + diff

     line1 <- MakeMLStim(250,gVideoHeight/2,l1,50,100)
     line2 <- MakeMLStim(gVideoWidth-250,gVideoHeight/2,l2,50,80)
     AddComplex(line1,gWin)
     AddComplex(line2,gWin)
     Draw()
     RemoveComplex(line1,gWin)
     RemoveComplex(line2,gWin)
     Wait(prestime)
#     WaitForAnyKeyPress()

    Show(header)
    Show(footer)
    Draw()     
    t1 <- GetTime()
    resp <-  WaitForListKeyPress(["<lshift>","<rshift>"])
    t2 <- GetTime()

    corr <- ScoreResp(resp,diff)
 
    ##Determine next diff semi-randomly
    ##if correct, move diff toward (or past) 0
    if(corr)
      {
        diff <- diff - Sign(diff) *5 + Floor(Random()*11)-5
      }else{
        diff <- diff + Sign(diff) *5 + Floor(Random()*11)-5
      }

    Hide(header)
    Hide(footer)
    Draw()
    Wait(500)
    FilePrint(fileout,gsubnum+"," +trial + "," +l1 + "," + l2 + "," +  diff + "," +resp + "," +corr +"," + t1 + "," + (t2-t1))
    trial <- trial + 1
  }

  inst.text <- "Thank you for participating in the study."
  Show(inst)
  Draw()
  WaitForAnyKeyPress()

}

define ScoreResp(resp,diff)
{
     if((resp == "<lshift>" and diff<0) or
         (resp == "<rshift>" and diff>0))
       {
          corr<- 1
       }else{
          corr <- 0
       }
 return corr
}


##This makes vertical M-L illusion stimuli
define MakeMLStim(x,y,length,tailsize, tailangle)
{
   
   ##Compute dx and dy for tails based on size and angle
   ## angle of 90 = straight out; 
   dx <- tailsize * Cos(tailangle-90)
   dy <- tailsize * Sin(tailangle-90)
   

   width <- 6
   ##first, make the line
   col <- MakeColor("white")
   l1 <- ThickLine(x,y-length/2,x,y+length/2,width,col)

   l2a <- ThickLine(x,y+length/2-1,x+dx,y+length/2+dy,width,col)
   l2b <- ThickLine(x,y+length/2-1,x-dx,y+length/2+dy,width,col)

   l3a <- ThickLine(x,y-length/2+1,x+dx,y-length/2-dy,width,col)
   l3b <- ThickLine(x,y-length/2+1,x-dx,y-length/2-dy,width,col)
  
   return [l1,l2a,l2b,l3a,l3b]
}


define AddComplex(comp,win)
  {
     loop(i,comp)
     {
        AddObject(i,win)
     }
  }


define RemoveComplex(comp,win)
  {
     loop(i,comp)
     {
        RemoveObject(i,win)
     }
  }
