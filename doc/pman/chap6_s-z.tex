\section{S}
\rl

\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+SampleN()+

\item[Description] Samples \verb+<number>+ items from list, returning
  a randomly- ordered list. Items are sampled without replacement, so
  once an item is chosen it will not be chosen again. If
  \verb+<number>+ is larger than the length of the list, the entire
  list is returned shuffled.  It differs from \verb+ChooseN+ in that
  \verb+ChooseN+ returns items in the order they appeared in the
  originial list.  It is implemented as \verb+Shuffle(ChooseN())+.
  \verb+SampleN+ is not a precompiled function, but rather is written
  in PEBL, and is located in \verb+pebl-lib/Design.pbl+.

\item[Usage]       	
\begin{verbatim}
SampleN(<list>, <n>)
\end{verbatim}

\item[Example]   	
\begin{verbatim}
SampleN([1,1,1,2,2], 5)     # Returns 5 numbers
SampleN([1,2,3,4,5,6,7], 3) # Returns 3 numbers from 1 and 7
\end{verbatim}

\item[See Also]    	\verb+ChooseN()+, \verb+SampleNWithReplacement()+, \verb+Subset()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+SampleNWithReplacement()+

\item[Description] \verb+SampleNWithReplacement+ samples
  \verb+<number>+ items from \verb+<list>+, replacing after each draw
  so that items can be sampled again.  \verb+<number>+ can be larger
  than the length of the list. It has no side effects on its
  arguments.  Is implemented as a PEBL function in
  \verb+pebl-lib/Design.pbl+

\item[Usage]        	
\begin{verbatim}
SampleNWithReplacement(<list>, <number>)
\end{verbatim}

\item[Example] 	
\begin{verbatim}
x <- Sequence(1:100,1)
SampleNWithReplacement(x, 10)
# Produces 10 numbers between 1 and 100, possibly 
# repeating some.
\end{verbatim}

\item[See Also]     	\verb+SampleN()+, \verb+ChooseN()+, \verb+Subset()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+SDTBeta()+

\item[Description] \verb+SDTBeta+ computes beta, as defined by signal detection theory.  It is implemented as a PEBL function in
  \verb+pebl-lib/Math.pbl+

\item[Usage]        	
\begin{verbatim}
SDTBeta(<hr>, <far>)
\end{verbatim}

\item[Example] 	
\begin{verbatim}

  Print(SDTBeta(.1,.9))  #.67032
  Print(SDTBeta(.1,.5))  #.88692
  Print(SDTBeta(.5,.5))  #1
  Print(SDTBeta(.8,.9))  #0.918612
  Print(SDTBeta(.9,.95)) #0.954803
\end{verbatim}

\item[See Also]\verb+SDTBeta()+,
\end{desc}

\rl

\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+SDTDPrime()+

\item[Description] \verb+SDTDPrime+  Is implemented as a PEBL function in
  \verb+pebl-lib/Math.pbl+

\item[Usage]        	
\begin{verbatim}
SDTDPrime(<hr>, <far>)
\end{verbatim}

\item[Example] 	
\begin{verbatim}

  Print(SDTDPrime(.1,.9))  #2.56431
  Print(SDTDPrime(.1,.5))  #1.28155
  Print(SDTDPrime(.5,.5))  #0
  Print(SDTDPrime(.8,.9))  #.43993
  Print(SDTDPrime(.9,.95)) #.363302

\end{verbatim}

\item[See Also]\verb+SDTBeta()+,
\end{desc}

\rl




\begin{desc}{Name/Symbol}
\item[Name/Symbol]   \verb+SeedRNG()+

\item[Description] Seeds the random number generator with \verb+<num>+
  to reproduce a random sequence.  This function can be used cleverly
  to create a multi-session experiment: Start by seeding the RNG with
  a single number for each subject; generate the stimulus sequence,
  then extract the appropriate stimuli for the current block. Remember
  to \verb+RandomizeTimer()+ afterward if necessary.

\item[Usage] 
\begin{verbatim}
SeedRNG(<num>) 
\end{verbatim}

\item[Example]	

\begin{verbatim}
    ##This makes sure you get the same random order across sessions
    ## for individual subjects.
     SeedRNG(gSubNum)
     stimTmp <- Sequence(1:100,1)
     stim <- Shuffle(stimTmp)
     RandomizeTimer()
\end{verbatim}

\item[See Also]	
     \verb+RandomizeTimer+
\end{desc}

\rl

\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+SendData()+

\item[Description]	Sends data on network connection.  Example of
  usage in demo/nim.pbl. You can only send text data.

\item[Usage]
\begin{verbatim}
 SendData(<network>,<data_as_string>)
\end{verbatim}

\item[Example]	

On 'server':
\begin{verbatim}
  net <- WaitForNetworkConnection("localhost",1234)
  SendData(net,"Watson, come here. I need you.")
  CloseNetworkConnection(net)
\end{verbatim}
On Client:
\begin{verbatim}
  net <- ConnectToHost("localhost",1234)
  value <-  GetData(net,20)
  Print(value)
  CloseNetworkConnection(net)
##should print out "Watson, come here. I need you."
\end{verbatim}
\item[See Also]
  \verb+ConnectToIP+,\verb+ConnectToHost+,\verb+WaitForNetworkConnection+,
   \verb+GetData+,\verb+ConvertIPString+, \verb+CloseNetworkConnection+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]   	\verb+Sequence()+

\item[Description] Makes a sequence of numbers from \verb+<start>+ to
  \verb+<end>+ at \verb+<step>+-sized increments. If \verb+<step>+ is
  positive, \verb+<end>+ must be larger than \verb+<start>+, and if
  \verb+<step>+ is negative, \verb+<end>+ must be smaller than
  \verb+<start>+. If \verb!<start> + n*<step>! does not exactly equal
  \verb+<end>+, the last item in the sequence will be the number
  closest number to \verb+<end>+ in the direction of \verb+<start>+
  (and thus \verb+<step>+).

\item[Usage] 
\begin{verbatim}
Sequence(<start>, <end>, <step>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Sequence(0,10,3)    # == [0,3,6,9]
Sequence(0,10,1.5)  # == [0,1.5,3,4.5, 6, 7.5, 9]
Sequence(10,1,3)    # error
Sequence(10,0,-1)   # == [10,9,8,7,6,5,4,3,2,1]
\end{verbatim}

\item[See Also]    	\verb+Repeat()+, \verb+RepeatList()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+SetCursorPosition()+

\item[Description] 	Moves the editing cursor to a specified character
		position in a textbox.

\item[Usage]
\begin{verbatim}
SetCursorPosition(<textbox>, <integer>)
\end{verbatim}

\item[Example]
\begin{verbatim}
SetCursorPosition(tb, 23)
\end{verbatim}

\item[See Also]   	\verb+SetEditable()+, \verb+GetCursorPosition()+, \verb+SetText()+, \verb+GetText()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+SetEditable()+

\item[Description] Sets the ``editable'' status of the textbox.  All
  this really does is turns on or off the cursor; editing must be done
  with the (currently unsupported) device function \verb+GetInput()+.

\item[Usage] 
\begin{verbatim}
SetEditable()
\end{verbatim}

\item[Example]
\begin{verbatim}

SetEditable(tb, 0)
SetEditable(tb, 1)
\end{verbatim}

\item[See Also]    	\verb+GetEditable()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+SetFont()+

\item[Description] Resets the font of a textbox or label.  Change will
  not appear until the next \verb+Draw()+ function is called.  Can be
  used, for example, to change the color of a label to give richer
  feedback about correctness on a trial (see example below).

\item[Usage]
\begin{verbatim}
SetFont(<text-widget>, <font>)
\end{verbatim}

\item[Example]   	
\begin{verbatim}
fontGreen <- MakeFont("vera.ttf",1,22,MakeColor("green"),
MakeColor("black"), 1)
fontRed   <- MakeFont("vera.ttf",1,22,MakeColor("red"),
MakeColor("black"), 1)
label <- MakeLabel(fontGreen, "Correct")

#Do trial here.       	

if(response == 1)
{
SetText(label, "CORRECT")
SetFont(label, fontGreen)
} else {
SetText(label, "INCORRECT")
SetFont(label, "fontRed)
}
Draw()
\end{verbatim}

\item[See Also]    	\verb+SetText()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}

\item[Name/Symbol] 	\verb+SetText()+

\item[Description] 	Resets the text of a textbox or label.  Change will not
		appear until the next Draw() function is called.

\item[Usage]
\begin{verbatim}
SetText(<text-widget>, <text>)
\end{verbatim}

\item[Example]
\begin{verbatim}
# Fixation Cross:
label <- MakeLabel(font, "+")
Draw()

SetText(label, "X")
Wait(100)
Draw()
\end{verbatim}

\item[See Also]    	\verb+GetText()+, \verb+SetFont()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Show()+

\item[Description] Sets a widget to visible, once it has been added to
  a parent widget.  This just changes the visibility property, it does
  not make the widget appear.  The widget will not be displayed until
  the \verb+Draw()+ function is called.

\item[Usage]
\begin{verbatim}
Show(<object>)
\end{verbatim}

\item[Example]
\begin{verbatim}
window <- MakeWindow()
image1  <- MakeImage("pebl.bmp")
image2  <- MakeImage("pebl.bmp")
AddObject(image1, window)
AddObject(image2, window)
Hide(image2)
Draw()
Wait(300)
Show(image2)
Draw()
\end{verbatim}

\item[See Also]     	\verb+Hide()+
\end{desc}

\rl




\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+ShowCursor()+

\item[Description] Hides or shows the mouse cursor.  Currently, the
  mouse is not used, but on some systems in some configurations, the
  mouse cursor shows up.  Calling ShowCursor(0) will turn off the
  cursor, and ShowCursor(1) will turn it back on.  Be sure to turn it
  on at the end of the experiment, or you may actually lose the cursor
  for good.

\item[Usage]
\begin{verbatim}
ShowCursor(<value>)
\end{verbatim}

\item[Example]
\begin{verbatim}
window <- MakeWindow()
ShowCursor(0)
## Do experiment here
##

## Turn mouse back on.
ShowCursor(1)

\end{verbatim}

\item[See Also] 
\end{desc}

\rl




\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+Shuffle()+

\item[Description] 	Randomly shuffles a list.

\item[Usage]    
\begin{verbatim}
Shuffle(list)
\end{verbatim}

\item[Example]
\begin{verbatim}
Print(Shuffle([1,2,3,4,5]))
# Results might be anything, like [5,3,2,1,4]
\end{verbatim}

\item[See Also]    	\verb+Sort()+, \verb+SortBy()+ \verb+ShuffleRepeat()+,
                    \verb+ShuffleWithoutAdjacents()+
\end{desc}

\rl




\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+ShuffleRepeat()+

\item[Description] 	Randomly shuffles  <list>, repeating <n> times.  Shuffles
  each iteration of the list separately, so you are guaranteed to go
  through all elements of the list before you get another.

\item[Usage]    
\begin{verbatim}
ShuffleRepeat(<list>, <n>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Print(ShuffleRepeat([1,2,3,4,5]),3)
# Results might be anything, like [5,3,2,1,4, 3,2,5,1,4, 1,4,5,3,2]
\end{verbatim}

\item[See Also]    	\verb+Sort()+, \verb+SortBy()+ \verb+ShuffleRepeat()+,
                    \verb+ShuffleWithoutAdjacents()+
\end{desc}

\rl



\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+ShuffleWithoutAdjacents()+

\item[Description] 	Randomly shuffles  <nested-list>, attempting to
  create a list where the nested elements do not appear adjacently in
  the new list. Returns a list that is flattened one level. It will
  always return a shuffled list, but it is not guaranteed to return
  one that has the non-adjecent structure specified, because this is
  sometimes impossible or very difficult to do randomly.  Given small
  enough non-adjacent constraints with enough fillers, it should be
  able to find something satisfactory.

\item[Usage]    
\begin{verbatim}
ShuffleWithoutAdjacents(<nested-list>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Print(ShuffleWithoutAdjacents([[1,2,3], [4,5,6], [7,8,9]])
## Example Output: 
## [8, 5, 2, 7, 4, 1, 6, 9, 3]
## [7, 4, 8, 1, 9, 2, 5, 3, 6]

## Non-nested items are shuffled without constraint
Print(ShuffleWithoutAdjacents([[1,2,3], 11,12,13,14,15,16]))
## output: [13, 11, 2, 14, 3, 15, 1, 16, 12]
##         [13, 12, 2, 16, 15, 11, 1, 14, 3]
##         [11, 1, 15, 2, 12, 16, 14, 13, 3]

## Sometimes the constraints cannot be satisfied.  9 will always
## appear in position 2
Print(ShuffleWithoutAdjacents([[1,2,3], 9])
## output: [3, 9, 1, 2]
##         [2, 9, 3, 1]
##         [3, 9, 2, 1]

   \end{verbatim}

\item[See Also]    	\verb+Shuffle()+, \verb+Sort()+, \verb+SortBy()+
        \verb+ShuffleRepeat()+, \verb+ShuffleWithoutAdjacents()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+Sign()+

\item[Description] 	Returns +1 or -1, depending on sign of argument.

\item[Usage]
\begin{verbatim}
Sign(<num>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Sign(-332.1)  # == -1
Sign(65)      # == 1

\end{verbatim}

\item[See Also]     	\verb+Abs()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+SignalFatalError()+

\item[Description] Stops PEBL and prints \verb+<message>+ to stderr.
  Useful for type-checking in user-defined functions.

\item[Usage]
\begin{verbatim}
SignalFatalError(<message>)
\end{verbatim}
If(not IsList(x))
{
 SignalFatalError("Tried to frobnicate a List.")
}
\item[Example]

\item[See Also]     	\verb+Print()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Sin()+

\item[Description]  	Sine of \verb+<deg>+ degrees.

\item[Usage]        	
\begin{verbatim}
Sin(<deg>)
\end{verbatim}
Sin(180)
Sin(0)
\item[Example]

\item[See Also]    	Cos(), Tan(), ATan(), ACos(), ATan() 
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+Sort()+

\item[Description] 	Sorts a list by its values from smallest to largest.

\item[Usage]       	
\begin{verbatim}
Sort(<list>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Sort([3,4,2,1,5]) # == [1,2,3,4,5]
\end{verbatim}

\item[See Also]    	\verb+SortBy()+, \verb+Shuffle()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+SortBy()+

\item[Description] 	Sorts a list by the values in another list, in ascending
		order.

\item[Usage]
\begin{verbatim}
SortBy(<value-list>, <key-list>)
\end{verbatim}

\item[Example]
\begin{verbatim}
SortBy(["Bobby","Greg","Peter"], [3,1,2]) 
# == ["Greg","Peter","Bobby"]
\end{verbatim}

\item[See Also]    	\verb+Shuffle()+, \verb+Sort()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+SplitString()+

\item[Description]	Splits a string into tokens. \verb+<split>+ must be a string. If 
		\verb+<split>+ is not found in \verb+<string>+, a list containing the entire 
		string is returned; if split is equal to \verb+""+, the each letter 
		in the string is placed into a different item in the list.  
		Multiple delimiters, as well as delimiters at the beginning 
		and end of a list, will produce empty list items. 
		Is implemented as a PEBL function in \texttt{pebl-lib/Design.pbl}

\item[Usage]
\begin{verbatim}
SplitString(<string>, <split>)
\end{verbatim}

\item[Example]      	
\begin{verbatim}
SplitString("Everybody Loves a Clown", " ") 
# Produces ["Everybody", "Loves", "a", "Clown"]
\end{verbatim}

\item[See Also]     	\verb+FindInString()+
\end{desc}

\rl




\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+Square()+
  
\item[Description]	Creates a square for graphing at x,y with size
  \verb+<size>+. Squares are only currently definable oriented in
  horizontal/vertical directions.  A square  must be added
  to a parent widget before it can be drawn; it may be added to
  widgets other than a base window.  The properties of squares may be
  changed by accessing their properties directly, including the FILLED
  property which makes the object an outline versus a filled shape.

\item[Usage]
\begin{verbatim}
Ellipse(<x>, <y>, <size>, <color>)
\end{verbatim}

\item[Example]	
\begin{verbatim}
  
  s <- Square(30,30,20, MakeColor(green))
  AddObject(s, win)
  Draw()

\end{verbatim}
\item[See Also]	 \verb+Circle()+, \verb+Ellipse()+, \verb+Rectangle()+, \verb+Line()+
\end{desc}

\rl



\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Sqrt()+ 

\item[Description]  	Square root of \verb+<num>+.

\item[Usage]        	
\begin{verbatim}
Sqrt(<num>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Sqrt(100)  # == 10
\end{verbatim}

\item[See Also]	
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+StDev()+ 

\item[Description]  Returns the standard deviation of \verb+<list>+.

\item[Usage]       	
\begin{verbatim}
StDev(<list>)        
\end{verbatim}

\item[Example]	
\begin{verbatim}
   sd <- StDev([3,5,99,12,1.3,15])        
\end{verbatim}

\item[See Also]     	\verb+Min()+, \verb+Max()+, \verb+Mean()+, \verb+Median()+, \verb+Quantile()+, \verb+Sum()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+StartEventLoop()+

\item[Description]  	NOT IMPLEMENTED. Advanced control of event loop.

\item[Usage]		

\item[Example]	

\item[See Also]	
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Stop()+	

\item[Description] Stops a sound playing in the background from
  playing.  Calling \verb+Stop()+ on a sound object that is not
  playing should have no effect, but if an object is aliased,
  \verb+Stop()+ will stop the file.  Note that sounds play in a
  separate thread, so interrupting the thread has a granularity up to
  the duration of the thread-switching quantum on your computer; this
  may be tens of milliseconds.

\item[Usage]
\begin{verbatim}
Stop(<sound-object>)
\end{verbatim}

\item[Example]     	
\begin{verbatim}
buzz <- LoadSound("buzz.wav")
PlayBackground(buzz)
Wait(50)
Stop(buzz)
\end{verbatim}

\item[See Also]    	\verb+PlayForeground()+, \verb+PlayBackGround()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+StringLength()+

\item[Description] 	Determines the length of a string, in characters.

\item[Usage]
\begin{verbatim}
StringLength(<string>)
\end{verbatim}

\item[Example]     	
\begin{verbatim}
StringLength("absolute")     # == 8
StringLength("   spaces   ") # == 12
StringLength("")             # == 0
\end{verbatim}

\item[See Also]    	\verb+Length()+, \verb+SubString()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+SubList()+

\item[Description] 	Extracts a list from another list, by specifying 
	     	beginning and end points of new sublist.

\item[Usage]
\begin{verbatim}
SubList(<list>, <begin>, <end>)
\end{verbatim}

\item[Example]     	
\begin{verbatim}
SubList([1,2,3,4,5,6],3,5)	# == [3,4,5]
\end{verbatim}

\item[See Also]    	\verb+SubSet()+, \verb+ExtractListItems()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Subset()+

\item[Description] Extracts a subset of items from another list,
  returning a new list that includes items from the original list only
  once and in their original orders.  Item indices in the second
  argument that do not exist in the first argument are ignored.  It
  has no side effects on its arguments.  Is implemented as a PEBL
  function in \verb+pebl-lib/Design.pbl+

\item[Usage]       	
\begin{verbatim}
Subset(<list>, <list-of-indices>)
\end{verbatim}

\item[Example]     	
\begin{verbatim}
Subset([1,2,3,4,5,6],[5,3,1,1])	# == [1,3,5]
Subset([1,2,3,4,5], [23,4,2])		# == [2,4]
\end{verbatim}

\item[See Also]   	\verb+SubList()+, \verb+ExtractItems()+, \verb+SampleN()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+SubString()+

\item[Description]  	Extracts a substring from a longer string.

\item[Usage]
\begin{verbatim}
SubString(<string>,<position>,<length>)
\end{verbatim}
  If position is larger than the length of the string, an empty string
  is returned.  If position + length exceeds the length of the string,
  a string from \verb+<position>+ to the last character of the string
  is returned.

\item[Example]
\begin{verbatim}
SubString("abcdefghijklmnop",3,5)	# == "cdefg"
\end{verbatim}

\item[See Also]	
\end{desc}

\rl





\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Sum()+ 

\item[Description]  Returns the sum  of \verb+<list>+.

\item[Usage]       	
\begin{verbatim}
Sum(<list>)        
\end{verbatim}

\item[Example]	
\begin{verbatim}
   sum <- StDev([3,5,99,12,1.3,15])      # == 135.3
\end{verbatim}

\item[See Also]     	\verb+Min()+, \verb+Max()+, \verb+Mean()+, \verb+Median()+, \verb+Quantile()+, \verb+StDev()+
\end{desc}

\rl

\section{T}
\rl


\begin{desc}{Name/Symbol}

\item[Name/Symbol] \verb+Tab()+

\item[Description]  Produces a tab character which can be added to a
  string. If displayed in a text box, it will use a 4-item tab stop.

\item[Usage]        \verb!Tab(3)!


\item[Example]     
\begin{verbatim}
         Print("Number: "  Tab(1) + number )
         Print("Value: "  Tab(1) + value )
         Print("Size: "  Tab(1) + size )
\end{verbatim}
\item[See Also]
\verb+Format()+, \verb+CR()+
\end{desc}

\rl     

\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Tan()+	

\item[Description] 	Tangent of \verb+<deg>+ degrees.

\item[Usage]       	
\begin{verbatim}
Tan(<deg>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Tan(180)
\end{verbatim}

\item[See Also]    	\verb+Cos()+, \verb+Sin()+, \verb+ATan()+, \verb+ACos()+, \verb+ATan()+ 
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+TimeStamp()+

\item[Description] Returns a string containing the date-and-time,
  formatted according to local conventions. Should be used for
  documenting the time-of-day and date an experiment was run, but not
  for keeping track of timing accuracy.  For that, use
  \verb+GetTime()+.
	     
\item[Usage]
\begin{verbatim}
TimeStamp()
\end{verbatim}

\item[Example]
\begin{verbatim}
a <- TimeStamp()
Print(a)
\end{verbatim}

\item[See Also]     	\verb+GetTime()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+ToInteger()+
              
\item[Description]  	Rounds a number to an integer, changing internal 
		representation.

\item[Usage]
\begin{verbatim}
ToInteger(<number>)
ToInteger(<floating-point>)
ToInteger(<string-as-number>)
\end{verbatim}

\item[Example]
\begin{verbatim}
ToInteger(33.332)  # == 33
ToInteger("3213")  # == 3213
\end{verbatim}

\item[See Also]    	\verb+Round()+, \verb+Ceiling()+, \verb+AbsCeiling()+, \verb+Floor()+, \verb+AbsFloor()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+ToFloat()+

\item[Description] 	Converts number to internal floating-point representation.

\item[Usage]
\begin{verbatim}
ToFloat(<number>)
\end{verbatim}

\item[Example]	

\item[See Also]	
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Token()+

\item[Description]  	NOT IMPLEMENTED.

\item[Usage]		

\item[Example]	

\item[See Also]	
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+ToNumber()+

\item[Description] Converts a variant to a number. Most useful for
  character strings that are interpretable as a number, but may also
  work for other subtypes.

\item[Usage]     
\begin{verbatim}
ToNumber(<string)
ToNumber(<number>)
\end{verbatim}

\item[Example]
\begin{verbatim}
a <- ToNumber("3232")
Print(a + 1)		# produces the output 3233. 
\end{verbatim}

\item[See Also]     	\verb+ToString()+, \verb+ToFloat()+, \verb+Round()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+ToString()+

\item[Description] Converts value to a string representation. Most
  useful for numerical values.  This conversion is done automatically
  when strings are combined with numbers.

\item[Usage]     
\begin{verbatim}
ToString(<number>)
ToString(<string>)
\end{verbatim}

\item[Example]
\begin{verbatim}
a <- ToString(333.232)
Print(a + "111")
# produces the output '333.232111'.
\end{verbatim}
		

\item[See Also] \verb+ToString()+, \verb|+|.
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+TranslateKeyCode()+

\item[Description] Translates a code corresponding to a keyboard key
  into a keyboard value.  This code is returned by some event/device
  polling functions.

\item[Usage]		

\item[Example]	

\item[See Also]	
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Transpose()+

\item[Description] Transposes or ``rotates'' a list of lists.  Each
  sublist must be of the same length.

\item[Usage]       	
\begin{verbatim}
Transpose(<list-of-lists>)
\end{verbatim}

\item[Example]     	
\begin{verbatim}
Transpose([[1,11,111],[2,22,222],[3,33,333], [4,44,444]])
# == [[1,2,3,4],[11,22,33,44],[111,222,333,444]]
\end{verbatim}

\item[See Also]    	\verb+Rotate()+
\end{desc}

\rl
\section{U}
\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Uppercase()+

\item[Description]  	Changes a string to uppercase.  Useful for testing user
	      	input against a stored value, to ensure case differences
	      	are not detected.

\item[Usage]
\begin{verbatim}
Uppercase(<string>)
\end{verbatim}

\item[Example]     
\begin{verbatim}
Uppercase("POtaTo")  # == "POTATO"
\end{verbatim}

\item[See Also]     	\verb+Lowercase()+
\end{desc}

\rl
\section{W}
\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+Wait()+ 

\item[Description] 	Waits the specified number of milliseconds, then returns. 

\item[Usage]
\begin{verbatim}
Wait(<time>)
\end{verbatim}

\item[Example]
\begin{verbatim}
Wait(100)
Wait(15)
\end{verbatim}

\item[See Also]	
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+WaitForAllKeysUp()+

\item[Description]	
               Wait until all keyboard keys are in the up
               position. This includes numlock, capslock, etc.
\item[Usage]		

\item[Example]	

\item[See Also]	

\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+WaitForAnyKeyDown()+

\item[Description]	
             Waits for any key to be detected in the down position.
             This includes numlock, capslock, etc, which can be locked
             in the down position even if they are not being held
             down.  Will return immediately if a key is being held
             down before the function is called. 

\item[Usage]		

\item[Example]	

\item[See Also]	
            WaitForAnyKeyPress()
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+WaitForAnyKeyDownWithTimeout()+

\item[Description] Waits until any key is detected in the down position, but will return
  after a specified number of milliseconds.

\item[Usage]
\begin{verbatim}
WaitForAnyKeyDownWithTimeout(<time>)
\end{verbatim}

\item[Example]	

\item[See Also]	
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+WaitForKeyDown()+

\item[Description]	

\item[Usage]		

\item[Example]	

\item[See Also]	
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+WaitForKeyListDown()+

\item[Description] Returns when any one of the keys specified in the
  argument is down. If a key is down when called, it will return immediately.

\item[Usage]
\begin{verbatim}
WaitForKeyListDown(<list-of-keys>)
\end{verbatim}

\item[Example]     	
\begin{verbatim}
WaitForKeyListDown(["a","z"])
\end{verbatim}

\item[See Also]	
 \end{desc}

\rl





\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+WaitForListKeyPressWithTimeout()+

\item[Description] Returns when any one of the keys specified in the
  argument is pressed. Will only return on a new keyboard event, and
  so a previously pressed key will not trip this function, unlike \verb+WaitForKeyListDown()+

\item[Usage]
\begin{verbatim}
 WaitForListKeyPress(<list-of-keys>,<timeout>,<style>)
\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+WaitForListKeyPress()+

\item[Description] Returns when any one of the keys specified in the
  argument is pressed, or when the timeout has elapsed; whichever
  comes first. Will only return on a new keyboard/timeout events, and
  so a previously pressed key will not trip this function, unlike
  \verb+WaitForKeyListDown()+.  The <style> parameter is currently
  unused, but may be deployed in the future for differences in how
  or when things should be returned.  Returns the value of the pressed
  key.  If the function terminates by exceeding the <timeout>,
  it will return the string \verb+"<unknown>"+.
\end{verbatim}

\item[Example]     	
\begin{verbatim}
  x <- WaitForListKeyPress(["a","z"],2000,1)
  if(x == "<unknown>") 
  {
     Print("Did Not Respond.")
  }
   
\end{verbatim}

\item[See Also]	
   \verb+WaitForKeyListDown+,\verb+WaitForListKeyPress+
 \end{desc}

\rl





\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+WaitForListKeyPress()+

\item[Description] Returns when any one of the keys specified in the
  argument is pressed. Will only return on a new keyboard event, and
  so a previously pressed key will not trip this function, unlike
  \verb+WaitForKeyListDown()+  Returns a string indicating the value
  of the keypress.

\item[Usage]
\begin{verbatim}
WaitForListKeyPress(<list-of-keys>)
\end{verbatim}

\item[Example]     	
\begin{verbatim}
WaitForListKeyPress(["a","z"])
\end{verbatim}

\item[See Also]	
   \verb+WaitForKeyListDown+,\verb+WaitForListKeyPressWithTimeout+
 \end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]  	\verb+WaitForKeyPress()+

\item[Description] Waits for a keypress event that matches the
  specified key.  Usage of this function is preferred over
  \verb+WaitForKeyDown()+, which tests the state of the key. Returns the
  value of the key pressed.

\item[Usage]
\begin{verbatim}
WaitForKeyPress(<key>)
\end{verbatim}

\item[Example]	

\item[See Also]     	\verb+WaitForAnyKeyPress()+, \verb+WaitForKeyRelease()+, \verb+WaitForListKeyPress()+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol] 	\verb+WaitForKeyUp()+

\item[Description]	

\item[Usage]		

\item[Example]	

\item[See Also]	
\end{desc}


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+WaitForNetworkConnection()+

\item[Description]	Listens on a port, waiting until another computer or process
  connects. Return a network object that can be used for communication.

\item[Usage]
\begin{verbatim}
   WaitForNetworkConnection(<port>)
\end{verbatim}

\item[Example]	

  See nim.pbl for example of two-way network connection.
\begin{verbatim}

  net <- WaitForNetworkConnection(1234)
  dat <- GetData(net,20)
  Print(dat)
  CloseNetworkConnection(net)
\end{verbatim}

\item[See Also]
  \verb+ConnectToHost+, \verb+ConnectToIP+,\verb+GetData+,\verb+WaitForNetworkConnection+,
   \verb+SendData+,\verb+ConvertIPString+,\verb+CloseNetworkConnection+
\end{desc}

\rl


\begin{desc}{Name/Symbol}
\item[Name/Symbol]	\verb+while+

\item[Description] `while' is a keyword, and so is part of the syntax,
  not a function per se.  It executes the code inside the \verb+{}+
  brackets until the test inside the \verb+()+ executes as false.
  This can easily lead to an infinite loop if conditions are not met.
  Also, there is currently no break statement to allow execution to
  halt early.  Unlike some other languages, PEBL requires that the
  \verb+{}+ be present.

\item[Usage]
\begin{verbatim}

while(<test expression)
{
 code line 1
 code line 2
}
\end{verbatim}

\item[Example] 
\begin{verbatim}
i <- 1
while(i <= 10)
{
 Print(i)
 i <- i + 1
}		# prints out the numbers 1 through 10
\end{verbatim}

\item[See Also] 	\verb+loop()+, \verb+{ }+


\end{desc}

\rl


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
