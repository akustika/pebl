
\chapter
{Overview  of  Object Subsystems}

In PEBL, complex objects are stored and automatically self-managed.
These objects include lists, graphical display widgets like images and
text displays, fonts, colors, audio files, and input or output files.
Objects are created and modified with special functions, but many of
their properties available directly for access and modification with a
\texttt{variable.property} syntax.  For example, the position of a
textbox is controlled by \verb+.X+ and \verb+.Y+ properties, and can
also be changed with the \verb+Move()+ function.  To move the label
\texttt{lab}, which is located at 100,100, to 150,100, you can either
do \texttt{Move(lab,150,100)} or \verb+lab.X <- 150+.  The available
properties and accessor function are listed in the decriptions of
their relevant objects below.


\section{Lists}

Lists are  incredibly useful and flexible storage
structures that play an important role in PEBL. A list is
simply a series of variables. It is  like an array, except
that it takes longer to access items later in the
list than items at the beginning. But it is much easier to
do things like split and combine lists of items than arrays of items. And given the speed of 
computers, accessing elements of a list is not too costly,
unless the list is really long (thousands of items). The \texttt{Nth} function can extract items from a list, but it is somewhat costly, and there are often better ways.


For example, suppose you want to print out every item in a list. Looping through, accessing, and printing all the items of a list is a traditional approach:
\begin{verbatim}
  list <- Sequence(1,9,1) #could also be written [1,2,3,4,5,6,7,8,9]
  len <- Length(list)
  i <- 1
  while (i <= len)
   {
     item <- Nth(list,i) 
     Print(item)
     i <- i + 1
  } 

\end{verbatim}
But this is inefficient for many reasons (it could be made more
efficient, but only with a loss in clarity). The biggest problem is
that the proper element of the list must be found during each
iteration, which takes longer as \texttt{i} grows. This poses a
considerable problem for larger lists.

However, there is an alternative.  Items from
lists can be iterated over using the `\texttt{loop}' command:  
\begin{verbatim}
  list <- Sequence(1,9,1)#could also be written [1,2,3,4,5,6,7,8,9]
  loop(item, list) 
  {
    Print(item)
  }
\end{verbatim}
These two code blocks produce identical output, but in the former block, each item of the list must be found on each iteration, which takes longer as \texttt{i} grows. In the latter block, a list item is bound directly to `\texttt{item}' on each iteration, so every item on the list takes the same amount of time. Not only is the latter more efficient, it is implemented in fewer lines of code, and so fewer errors (like forgetting to increment \texttt{i}) are possible.

A caveat when using lists: Some functions operate on lists to produce
new lists (sub-lists, re-ordered lists, etc.). When the lists contain
simple data types (numbers, strings, etc.), entirely new data
structures are created. But when the data structures are complex
(windows, sounds, images, etc.), the objects are not copied. Only new
pointers to the original objects are created. So if you change the
original object, you may end up accidentally changing the new
object. Although that is relatively difficult, because PEBL allows
only limited modification of existing data structures, it is still
possible. This is a special case of the copy/assignment issue
discussed in Section~\ref{sec:copies_and_ass}:~Copies and Assignment.




\section{Fonts}

PEBL uses truetype fonts for the display of text in labels and other text
widgets.  In addition to the filename, font objects have the following properties: style (i.e., normal, bold, italic, underline), size (in points),
foreground color, background color, and whether it should be rendered
anti-aliased.

We distribute a series of high-quality freely available
and redistributable fonts, including the Bitstream Vera series,
freefont series, and a few others.  These include
the typeface/files shown below \ref{tab:fonts}:

\begin{table}[htbp]
\caption{Typeface/Files Available in PEBL}
\begin{tabular}{ll}
\toprule
\textbf{Filename}&\textbf{Description}\\
\midrule
\multicolumn{2}{c}{FreeFont Fonts}\\
\texttt{FreeSans.ttf} &Simple Clean sans serif font\\
\texttt{FreeSansBold.ttf}& \\
\texttt{FreeSansOblique.ttf}&\\
\texttt{FreeSansBoldOblique.ttf}&\\
\texttt{FreeMono.ttf}& Courier-like fontface\\
\texttt{FreeMonoBold.ttf}& \\
\texttt{FreeMonoOblique.ttf}& \\
\texttt{FreeMonoBoldOblique.ttf}& \\
\texttt{FreeSerif.ttf}& Similar to Times New Roman\\
\texttt{FreeSerifBold.ttf}& \\
\texttt{FreeSerifItalic.ttf}&\\
\texttt{FreeSerifBoldItalic.ttf}& \\
\midrule
\multicolumn{2}{c}{Fontforge Fonts}\\
\texttt{Caliban.ttf}&  Helvetica-style  \\
\texttt{CaslonRoman.ttf}& Quirky Roman Font series\\
\texttt{CaslonBold.ttf}&\\
\texttt{CaslonItalic.ttf}&\\
\texttt{Caslon-Black.ttf}&\\
\texttt{Humanistic.ttf}&Sharp, refined fontface\\
\midrule
\multicolumn{2}{c}{SIL Fonts}\\

\texttt{DoulosSILR.ttf}&Comprehensive font with roman and cyrillic glyphs\\
\texttt{GenR102.ttf}& Includes many latin alphabet letters\\
\texttt{GenI102.ttf}& \\
\texttt{CharisSILR.ttf}& Like doulos, optimized for printing\\
\texttt{CharisSILB.ttf}&\\
\texttt{CharisSILI.ttf}& \\    
\texttt{CharisSILBI.ttf}& \\   
\midrule
\multicolumn{2}{c}{PEBL Fonts}\\
\texttt{Stimulasia.ttf}& A small set of arrow/boxes\\
\midrule
\multicolumn{2}{c}{Bitstream Vera Series}\\
\texttt{Vera.ttf}    &     Sans serif Roman-style base font\\
\texttt{VeraMono.ttf}&     Sans serif Roman-style mono-spaced base font\\
\texttt{VeraSe.ttf}  &     Serif Roman-style base font (similar to times)\\
\texttt{VeraBd.ttf}  &     Bold Vera\\
\texttt{VeraIt.ttf}  &     Italic Vera\\
\texttt{VeraBI.ttf}  &     Bold Italic Vera\\
\texttt{VeraMoBd.ttf}&     Bold Vera Mono\\
\texttt{VeraMoIt.ttf}&     Italic Vera Mono\\
\texttt{VeraMoBI.ttf}&     Bold Italic Vera Mono\\
\texttt{VeraSeBd.ttf}&     Bold Serif Vera\\
\bottomrule
\end{tabular}
\label{tab:fonts}
\end{table}



These should always be available for use in experiments.  The
\texttt{fonts.pbl} script in the demo/ directory will display what
symbols from each of these fonts looks like.

To use, you need only specify the font name in the \texttt{MakeFont()} function:
\begin{verbatim}
  colorRed  <- MakeColor("red")
  colorGrey <- MakeColor("grey")
  myFont    <- MakeFont("VeraMono.ttf",0,22,colorRed,colorGrey,1)
\end{verbatim}
This code makes a red 22-point anti-aliased font on a grey background. 
Other fonts may be used by specifying their absolute pathname 
or copying them to the working directory.


Accessible font properties:
\begin{verbatim}
  font.FILENAME
  font.BOLD
  font.UNDERLINE
  font.ITALIC
  font.SIZE
  font.FGCOLOR
  font.BGCOLOR
  font.ANTIALIASED
\end{verbatim}
 


\section{Colors} 

Colors are PEBL objects.  A color can be created by specifying its name 
using the \texttt{MakeColor()} function, or by specifying its RGB values using the \texttt{MakeColorRGB()} function. A list of colors and their respective RGB values can be found in the \texttt{Colors.txt} file in the documentation directory. There are nearly 800 from which to choose, so you can create 
just about anything you can imagine.

Accessible color properties:
\begin{verbatim}
  color.RED
  color.GREEN
  color.BLUE
  color.ALPHA
\end{verbatim}
 

\section{Windows}

To run an experiment, you usually need to create a window in which 
to display stimuli.  This is done with the \texttt{MakeWindow()} function. \texttt{MakeWindow()} will create a grey window by default, or you can 
specify a color.  Currently, an experiment can have only one window.


\section{Graphical Widgets}

Graphical widgets are the building blocks of experimental stimuli. 
Currently, three widgets are available: images, labels, and textboxes.  
More complicated widgets are in progress or planned.

To be used, a widget must be created and added to a parent window, and
then the parent window must be drawn.  You can hide widgets with the
\texttt{Hide()} function, and show them with the \texttt{Show()}
function; however, this affects only the visibility of the widget: it
is still present and consuming memory. Widgets can be moved around on
the parent window using the \texttt{Move()} function. \texttt{Move()}
moves the center of an image or label to the specified pixel, counting
from the upper-left corner of the screen. \texttt{Move()} moves the
upper left-hand corner of textboxes.  For the sake of convenience, the
\texttt{MoveCorner} function is available, which will move an image or
label by its upper left-hand corner.

You should remove widgets from their parent window when you are
finished using them.

All widgets have several properties available for controlling their
behavior.
\begin{verbatim}
  widget.name
  widget.X
  widget.Y
  widget.WIDTH
  widget.HEIGHT
  widget.VISIBLE
  widget.ROTATION
  widget.XZOOM
  widget.YZOOM
\end{verbatim}

  

\section{Images}

PEBL can read numerous image types, courtesy of the
\texttt{SDL\_image} library.  Use the \texttt{MakeImage()} function to
read an image into an image object.  As images are often used as
stimuli, \texttt{Move()} centers the image on the specified point.  To
move by the upper-left hand corner, use the PEBL-defined
\texttt{MoveCorner()} function:
\begin{verbatim}
  define MoveCorner(object, x, y)
  {
   size    <- GetSize(object)
   centerX <- x + First(size)/2
   centerY <- y + Last(size)/2
   Move(object, centerX, centerY)
  }
\end{verbatim}

Images have all the properties available for widgets, but the width
and height can only be read, and not set.  Width and height are
controlled by the dimensions of the image file.

\section{Shapes}
PEBL allows you to define a number of shape objects that can be added
to another widget.  A demonstration script exercising these shapes is found in demo/shapes.pbl.

The following is a list of shape and their properties.

\subsection{Circle}
\emph{Description:} A standard circle.  Move commands move the center
  of the circle to the specified location.\\

\emph{Command:}  \verb+Circle(<x>,<y>,<r>,<color>,<filled>)+\\

\emph{Properties:}
.name\\
.filled = {0,1} (whether it is filled)\\
.color (color) \\
.x  (x position of center) \\
.y  (y position of center)\\
.height (read-only height)\\
.width (read-only width)\\
.R  (radius)\\

\subsection{Ellipse}

\emph{Description:} An ellipse, with height and width differing.
  Cannot be pointed in an arbitrary direction.  Move commands move the center
  of the shape to the specified location.

\emph{Command:}  \verb+Ellipse(<x>,<y>,<rx>,<ry>,<color>,<filled>)+\\

\emph{Properties:}
.name\\
.filled = {0,1} (whether it is filled)\\
.color (color) \\
.x  (x position of center) \\
.y  (y position of center)\\
.height (read-only height)\\
.width (read-only width)\\
.rx  (x radius)\\
.ry  (y radius


\subsection{Square}

\emph{Description:} A square. Move commands move the center
  of the shape to the specified location.

\emph{Command:}  \verb+Square(<x>,<y>,<size>,<color>,<filled>)+\\

\emph{Properties:}\\
.name\\
.filled = 0,1 (whether it is filled)\\
.color (color) \\
.x  (x position of center) \\
.y  (y position of center)\\
.height (read-only height)\\
.width (read-only width)\\
.dx, .dy, .size  (Length of side)\\


\subsection{Rectangle}
\emph{Description:} A Rectangle. Move commands move the center
  of the rectangle to the specified location.

\emph{Command:}  \verb+Rectangle(<x>,<y>,<dx>,<dy>,<color>,<filled>)+\\

\emph{Properties:}
.name\\
.filled = {0,1} (whether it is filled)\\
.color (color) \\
.x  (x position of center) \\
.y  (y position of center)\\
.height (read-only height)\\
.width (read-only width)\\
.dx, (width)
.dy,  (height)\\



\subsection{Line}
\emph{Description:} A Line. Move commands move the center
  of the line to the specified location.

\emph{Command:}  \verb+Line( <x>, <y>,<dx>,<dy>,<color>)+\\

\emph{Properties:}
.color (color) \\
.x  (x position of start) \\
.y  (y position of start)\\
.width, (x length)\\
.height,  (y length)\\




\subsection{Polygon}
\emph{Description:} An arbitrary polygon. 

\emph{Command:}  \verb+Polygon( <x>, <y>,<xpoints>,<ypoints>,<color>,<filled>)+\\

\emph{Properties:}
.name\\
.color (color) \\
.x  (x position of start) \\
.y  (y position of start)\\

\subsection{Bezier}
\emph{Description:} An arbitrary bezier curve.

\emph{Command:}  \verb+Bezier( <x>, <y>,<xpoints>,<ypoints>,<steps>,<color>)+\\

\emph{Properties:}
.name\\
.color (color) \\
.x  (x position of start) \\
.y  (y position of start)\\


\section{Text Labels}

You can create a text label object with the \texttt{MakeLabel()} function, 
which requires specifying a font, and the foreground and background colors.  Labels are only a single line of text. Like images, when you move them,
they center on the specified point.

The text inside a label can be extracted with \texttt{GetText()} 
and set with \texttt{SetText()}. When you change a text object, 
it will not appear until the next time you call a \texttt{Draw()} function.

Text labels have all the regular widget properties, plus:
\begin{verbatim}
  label.TEXT 
  label.FONT
\end{verbatim}
  


The \verb+.HEIGHT+ and \verb+.WIDTH+ accessible, but cannot be changed
because they are controlled by the text and the font size.


\section{Text Boxes}

A text box is a graphical widget that contains a body of text.  Text
automatically wraps when it is too long to fit on a single line.  Like
labels, the text inside a TextBox can be extracted with
\texttt{GetText()} and set with \texttt{SetText()}. When a text object
is changed, it rerenders immediately, but does not appear until the
next time a \texttt{Draw()} function is called.


Textbox properties:
\begin{verbatim}
   textbox.EDITABLE
   textbox.CURSORPOS 
\end{verbatim}
 


\section{User-Editable Text Boxes}

Text box editing can be performed using the \verb+GetInput(<textbox>,<escape-key>)+ function.  This returns the text that is present in the box when the participant hits the key associated with \verb+<escape-key>+.  
\verb+<escape-key>+ is just a text-based code that describes the keypress 
that should be checked for exit. Typical escape-key options include:
\begin{verbatim}
  "<return>"
  "<esc>"
  "<backspace>"
  "<kp_enter>"
  " "
  "A"
\end{verbatim}
 
See the Keyboard Entry section below for a more complete list.

Translation from string to keyboard input is still crude, 
and is handled in \texttt{src/utility/PEBLUtility.cpp:TranslateString} 


\section{Audio}

Currently, audio output is very primitive, and there are no facilities for recording or analyzing audio input. Audio \texttt{.wav} files can be loaded with the \texttt{LoadSound()} function, which returns an audio stream object that can be played  with either the \texttt{PlayForeground()} or \texttt{PlayBackground()} functions.  
The \texttt{PlayForeground()} function returns once the sound is finished playing; \texttt{PlayBackground()} returns immediately and the sound plays in a separate thread.  When using \texttt{PlayBackground}, playing can be stopped using the \texttt{Stop()} function.  If another \texttt{PlayForeground()} or \texttt{PlayBackground()} is then used,
the initial sound will immediately terminate and the new file will play. Currently, PEBL can only play one sound at a time.


\section{Keyboard Entry}

PEBL can examine the state of the keyboard, and wait for various
keyboard events to happen. Functions such as
\texttt{WaitForKeyDown()}, \texttt{WaitForAnyKeyDown()}, etc., allow
you to collect responses from subjects. Most keys are specified by
their letter name; others have special names:
\begin{verbatim}
"<left>"
"<up>"
"<down>"
"<right>"
"<enter>"
"<return>"
"<esc>"
"<backspace>" or "<back>"
"<kp_0>" through "<kp_9>", as well as "<kp_period>", "<kp_divide>",
 "<kp_multiply>", "<kp_minus>", "<kp_plus>", "<kp_equals>",
"<kp_enter>" for  keypad keys.

 "<insert>","<delete>", "<home>", "<end>","<pageup>","<pagedown>" for other
special keys.
\end{verbatim}

Function keys <F1> through <F15>.

Also, the traditional "modifier" keys can serve as normal keys:


\begin{verbatim}
<lshift>, <rshift> <numlock>, <capslock>, <scrollock>, 
<rctrl>, <lctrl>, <ralt>,<lalt>,<rmeta>,<lmeta>,<lsuper>,
<rsuper>,<mode>,<compose>

\end{verbatim}


\section{Files}

Files are objects that can be read from or written to using several PEBL functions. To use a file object, create one using one of the functions 
listed below.  Each function returns a file object:
\begin{verbatim}
FileOpenRead()
FileOpenWrite()
FileOpenAppend()
\end{verbatim}

For example, you can use the command \texttt{myfile <-
  FileOpenRead("stimuli.txt")} 
to create `\texttt{myfile}', a readable
file stream.


Other Functions described below allow filestreams to be written to 
or read from.  When you are finished, you can close a filestream 
Using the `\texttt{FileClose()}' function.


\section{Network Connections}

PEBL has limited ability to open and communicate via  TCP/IP
connections, either some other system (e.g., for synchronizing with an
e.e.g. or eyetracking computer), or another computer running PEBL
(e.g., to create multi-subject game theory experiments or to have an
experimenter controlling the task from another computer.)

\subsection{TCP/IP Overview}
TCP/IP is a protocol by which computers can talk to one another.  It
is fairly barebones, and PEBL tries to hide much of its
complexity. The information you send from one computer to another is
guaranteed to arrive in the correct order, at the potential cost of
serious delays, especially if the computers are on different networks
or in different locations.  Furthermore, connecting PEBL to another
computer in this way is a potential security risk. However, the
ability to transfer information between computers opens up huge
potential for the types of experiments that can be constructed.

\subsection{Addresses and Ports}
To do this, you first must open a network object to communicate with
another computer.  To do this, you must know (1) the IP number (like
127.0.0.1) or hostname (like myname.myschool.edu) of the computer you
want to connect to, and (2) the port you want to connect on. You can even
use the protocol to connect to another program running on your own
computer, by specifying an IP address of 127.0.0.1, or the hostname
``localhost''.  A port is
a number--usually 2 to 5 digits, specifying a type of service
on your computer. Many ports are frequently used for specific types of
communication, but you can use any port you wish to communicate, as
long as both computers know this port. Most ports on your computer
should be blocked by default, so you may need to turn off your
firewall or allow your chosen port to pass through the security or you
may have trouble communicating.

To allow two PEBL programs to communicate, you need to decide that one
computer is the ``server'' and the other is the ``client''.  On the
server, you execute the function
\texttt{WaitForNetworkConnection(port)}, which listens on the
specified port until the client tries to connect.  After the server is
started, the client calls \texttt{ConnectToHost(hostname, port)} or
\texttt{ConnectToIP(ipnum, port)}, depending upon whether you are using the
hostname or ip address.  Typically, ip numbers are specified by four
three-digit numbers separated by dots, like 196.168.0.1. This actually
represents a 4-byte integer, and this 4-byte integer is what
\texttt{ConnectToIP()} expects.  To create that integer, use the
function \\ \texttt{ConvertIPString(ipnum)}, which accepts an IP address
specified in a string.  So, you can use:\\
\texttt{net <- ConnectToIP(ConvertIPString( "127.0.0.1"), 1234)}\\
to create a
connection to another program listening on port 1234 on your own
computer.  These functions all return a network object (e.g.,
\texttt{net}) that must be
used in later communication.

\subsection{Sending and Receiving Data}
Once connected, the distinction between client and server essentially
disappears.  However, to communicate, one computer must send data with
the \texttt{SendData(net, data)}, and the other must receive the
data, using the \texttt{GetData(net, size)} function.  PEBL can
only send text strings, and you must know the length of the message
you want to receive.  More complex communication can be done by
creating a set of PEBL functions that encapsulate messages into text
strings with templated headers that specify the message length.  Then,
to receive a message, you first read the fixed-length header,
determine how much more data needs to be read, then read in the rest
of the data. 


\subsection{Closing networks}
If you are using a network connection to synchronize timing of two
computers, you probably want to close the network connection with
\texttt{CloseNetworkConnection(net)} after you have synchronized, to
avoid any extra overhead.

A simple example of an experiment that uses TCP/IP to communicate is
the NIM game in  demo/nim.pbl.

\section{The Event Loop}

To assist in testing for multiple input events simultaneously, 
PEBL implements an event loop that will quickly scan multiple conditions
and execute proper results whenever any one condition is met.  
This is currently primarily a back-end system 
which will be developed more in the future.


\section{Errors and Warnings}

PEBL does a great deal of error-checking to ensure that your program
will run.  If you crash with a segmentation fault, this is an error
and you should report it.  When a fatal error or non-fatal warning
occurs, PEBL attempts to identify the location in your input file that
led to the warning.  On Linux, the warning and this location are
printed to the command-line upon exit; on MS Windows, they are printed
to the file \texttt{stderr.txt}.

You can use the error system in your own scripts with the
\texttt{SignalFatalError()} function.  This is especially useful in
combination with the functions testing the type of object passed into 
the function.  To ensure proper processing and ease of debugging, test
the format of an argument passed into a function:

\begin{verbatim}
define MyFunction(par)
 {
   if(not IsList(par))
   {SignalFatalError("MyFunction was passed a non-list variable.")}

   ## Do stuff here.
 }
\end{verbatim}
 


\section{Paths and Path Searching}

Numerous functions and objects open files on your computer to read in
information such as graphics, sounds, fonts, program files, and text files.  When you attempt to open a file, PEBL will search in a number of places, 
in this order:
\begin{itemize}
\item
The (current) working directory
\item
The directory of each file specified in the command line arguments
\item
media/fonts
\item
media/sounds
\item
media/images
\item
media/text
\end{itemize}
  
You can also specify other paths to be searched by specifying them on the command line.  Be sure to end the directory with whatever is appropriate for your platform, e.g.~ `\char92' on Microsoft Windows or `/' on Linux.

\section{Provided Media Files}
\label{sec:media}

PEBL comes with various media files that can be specified from 
any script without including the complete path.  If a user's file has
the same name, it will be loaded before the PEBL-provided version.
Table \ref{tab:media} describes the files included.
\vspace{1cm}

\begin{longtable}{ll}
\caption{Media Files Provided with PEBL} \label{tab:media}\\
\toprule
\textbf{Name}& \textbf{Description} \\
\midrule
\addlinespace[.2cm]
\endfirsthead

\midrule
\textbf{Name}& \textbf{Description} \\
\midrule
\addlinespace[.2cm]
\endhead

\midrule
\endfoot

\bottomrule
\endlastfoot

\multicolumn{2}{l}{\textbf{In `media/fonts/'}:}\\
\addlinespace[.2cm]
%\cmidrule(l{0cm}r{1cm}){1-1}

Listing of fonts appears in Table~\ref{tab:fonts}\\
\addlinespace[.1cm]
\midrule
\addlinespace[.2cm]
\multicolumn{2}{l}{\textbf{In `media/images/'}:} \\
%\cmidrule(l{0cm}r{1cm}){1-1}
\addlinespace[.2cm]

\texttt{pebl.bmp}         & Demonstration bitmap image \\
\texttt{pebl.png}         &Demonstration PNG image \\
\texttt{smiley-small.png} &25x25 smiley face\\
\texttt{frowney-small.png}&25x25 frowney face\\
\texttt{smiley-large.png} &100x100 smiley face\\
\texttt{frowney-large.png}&100x100 frowney face\\
\texttt{plus.png}         &A green plus sign\\
\texttt{x.png}            &A red x sign, matching the red plus\\
\addlinespace[.1cm]
\midrule
\addlinespace[.2cm]
\multicolumn{2}{l}{\textbf{In `media/sounds/'}:}\\
%\cmidrule(l{0cm}r{1cm}){1-1}
\addlinespace[.2cm]

\texttt{buzz500ms.wav}   &A 500-ms buzzer\\
\texttt{chirp1.wav}      &A chirp stimulus\\
\texttt{boo.wav}         &A really bad booing sound\\
\texttt{cheer.wav}       &A pretty lame cheering sound\\
\texttt{beep.wav}        &A simple beep\\
\addlinespace[.1cm]
\midrule
\addlinespace[.2cm]
\multicolumn{2}{l}{\textbf{In `media/text/'}:}\\
%\cmidrule(l{0cm}r{1cm}){1-1}
\addlinespace[.2cm]
\texttt{Consonants.txt}  &List of all consonants, both cases\\
\texttt{Digits.txt}               &List of digits 0-9\\
\texttt{DigitNames.txt}           &List of digit names\\
\texttt{Letters.txt}              &All letters, both cases\\
\texttt{Lowercase.txt}            &Lowercase letters\\
\texttt{LowercaseConsonants.txt}  &Lowercase Consonants\\
\texttt{LowercaseVowels.txt}      &Lowercase Vowels\\
\texttt{Uppercase.txt}            &Uppercase Letters\\
\texttt{UppercaseConsonants.txt}  &Uppercase Consonants\\
\texttt{UppercaseVowels.txt}      &Uppercase Vowels\\
\texttt{Vowels.txt}               &Vowels (both cases)\\

\end{longtable}

Additionally, the PEBL Project distributes a number of other media
files separately from the base system.  These are available for separate
download on the pebl website (http://pebl.sourceforge.net), and
include a set of images (including shapes and sorting-task cards), and
a set of auditory recordings (including beeps, the digits 0-10, and a
few other things).

\vspace{1cm}


\section{Special Variables}

There are a number of special variables that be set by PEBL, 
and can later be accessed by an experiment. These are described in table~\ref{tab:special}.

\begin{table}[htbp]
\caption{Special Variables in PEBL}

\begin{tabular}{ll}
\toprule
\textbf{Name}&\textbf{Purpose}\\
\midrule
\verb+gKeepLooping+ & Controls continued execution in event loop. \\
 &           (Not currently useful).\\
\addlinespace[.2cm]
\verb+gSleepEasy+      &Sets 'busy-waiting' to be either on or off.\\
                       &Busy-waiting can improve timing, but is often\\
                       &not needed and pegs CPU.   \\
\verb+gVideoWidth+  &	The width in pixels of the display (set by\\
             &  default or command-line option). Changing \\
             &  this before calling \verb+MakeWindow+ will change \\
             &  display width, if that width is available. \\
\addlinespace[.2cm]
\verb+gVideoHeight+ & 	The height in pixels of the display (set by\\
             & 	default or command-line). Changing this before calling \\
             &  \verb+MakeWindow()+ will change the display height, if that \\
             &  height is available.\\
\addlinespace[.2cm]
\verb+gVideoDepth+    &      	The bit depth of the video.\\

\addlinespace[.2cm]
\verb+gSubNum+      &  A global variable set to whatever follows the \verb+--s+ or \\
             & \verb+--S+ command-line argument.  If no argument is given, \\
             & defaults to 0.\\
\verb+gQuote+ &A quotation mark: ".  Use it to add quotes in text.\\
\verb+gClick+ &[x,y] location of last click, set by WaitForClickOnTarget.\\


\bottomrule
\end{tabular}
\label{tab:special}
\end{table}






%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
