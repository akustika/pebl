#!/usr/local/bin/pebl
define Start(lPar)
{

## Implicit Association Test
## (c) 2005 Shane T. Mueller & Elizabeth S. Veinott
##  stmuelle@indiana.edu

##############################################
##  To customize, edit the text files words-bad.txt and words-good.txt
##  so that they include the 'good' and 'bad' word categories.  Place
##  all relevant pictures in the /stim subdirectory.  Edit the files
##  picnames-good.txt and picnames-bad.txt so that they contain a list
##  of the words you care about.  Be sure to NOT leave blank lines at the 
##  end of these files, as they will be read in as blank words/filenames.
##
##  The basic category names can be changed below.
##  To specify a subject number, run with the windows launcher
##  and an appropriately specified argument -v subnum.  
##  If no subject number is specified, it uses 0, overwriting previous
##  versions.



##############################################
## To change the stimuli, change the following
## labels.  The changes will be propogated in
## the instructions and the response labels.
##############################################
  goodWordTitle <- "Sweet Things"
  badWordTitle  <- "Tools"
  goodPicTitle  <- "Pictures of Good Things"
  badPicTitle   <- "Pictures of Bad Things"


  goodWordText <- Lowercase(goodWordTitle)
  badWordText  <- Lowercase(badWordTitle)
  goodPicText  <- Lowercase(goodPicTitle)
  badPicText   <- Lowercase(badPicTitle)



##This 
  if(IsList(lPar))
     {
            gSubNum   <- ToNumber(First(lPar))
          } else  {
       gSubNum <- 0
    }

  gFileOut <- FileOpenWrite("iat-" + gSubNum + ".dat")
  grey <- MakeColor("GREY")
  red <- MakeColor("RED")
  black <- MakeColor("BLACK")
  white <- MakeColor("white")
 
  gFont <- MakeFont("Vera.ttf",0,44,black, grey,1)
  fontInst  <- MakeFont("Vera.ttf",0,30,black,grey,1)
  gRedFont  <- MakeFont("Vera.ttf",0,80,red, grey,1)
  fontInst1 <- MakeFont("Vera.ttf",0,20,black,white,1)
  gCorrection <- MakeLabel("X",gRedFont)
 
  gWin <- MakeWindow()
  
  picNamesGood <- FileReadList("picnames-good.txt")
  picNamesBad  <- FileReadList("picnames-bad.txt")

 #read in the pictures
  goodpix <-[]
  loop(i,picNamesGood)
  {
    x <-  MakeImage(i)
    goodpix <- Append(goodpix, [x,i])
  }
  #Add type/valence tags.
  goodPicStim <- Transpose(Merge(Transpose(goodpix),[Repeat(1,Length(goodpix)), Repeat(1,Length(goodpix))]))


 #read in the pictures
  badpix <-[]
  loop(i,picNamesBad)
  {
    x <-  MakeImage(i)
    badpix <- Append(badpix, [x,i])
  }
  #Add type/valence tags.
  badPicStim <- Transpose(Merge(Transpose(badpix), [Repeat(1,Length(badpix)), Repeat(2,Length(badpix))]))



 #Create Word Labels
  goodWords <- FileReadList("words-good.txt")
  badWords  <- FileReadList("words-bad.txt")

  goodLabels <-[]
  loop(i,goodWords)
  {
    x <-  MakeLabel(i,gFont)
    goodLabels <- Append(goodLabels,[x,i])
  }
  #Add type/valence tags.
  goodWordStim <- Transpose(Merge(Transpose(goodLabels),[ Repeat(2,Length(goodLabels)), Repeat(1,Length(goodLabels))]))


  badLabels <-[]
  loop(i,badWords)
  {
    x <-  MakeLabel(i,gFont)
    badLabels <- Append(badLabels, [x,i])
  }
  #Add type/valence tags.
  badWordStim <- Transpose(Merge(Transpose(badLabels), [Repeat(2,Length(badLabels)), Repeat(2,Length(badLabels))]))

   gLeftInst <- MakeTextBox("", fontInst,120,250)
   gRightInst <- MakeTextBox("", fontInst,120,250)


   #########################################################################################
   ## Uncomment the following if you want to collect NIMH demographics.
   ##demoFile <- "iat-demo.dat"
   ##GetNIHMDemographics(gWin,demoFile)
   #########################################################################################



   AddObject(gLeftInst, gWin)
   AddObject(gRightInst, gWin)
   Move(gLeftInst,50,100)
   Move(gRightInst,850,100)
   Show(gLeftInst)
   Show(gRightInst)

   trial <- 1
   round <- 1



  ################################################
  ##   BLOCK 1:  Clean vs Dirty PICTURES
  ################################################

   instructions <- "First, you will be asked to categorize two sets of pictures.  Some will be " + goodPicText +
                   ",  whereas others will depict " + badPicText +
                   "  Your goal is to determine which category each picture  " +
                   "belongs in, as quickly and accurately as possible.  If you categorize the picture  " +
                   "incorrectly, a red X will appear on the screen until you make the correct response. " +
                   "    Press the 'X' key to begin."

   
   instructBox <- MakeTextBox(instructions, fontInst1,400,400)

   SetText(gLeftInst, "1:   " + badPicTitle)
   SetText(gRightInst,"2:   " + goodPicTitle)

   AddObject(instructBox,gWin)
   Move(instructBox,300,200)
   Show(instructBox)
   Draw()
   WaitForKeyPress("X")
   Hide(instructBox)
   Draw()


 

    #In round 1, stimuli should be just the pictures (20 of each)
   stimAll <- Shuffle(Merge(SampleBalanced(goodPicStim,20), SampleBalanced(badPicStim,20)))

   Wait(2500) 
   loop(i,stimAll)
   { 

     FilePrint_(gFileOut, gSubNum + " " + trial + " " +  round + " ")
     MatchTrial(First(i), Nth(i,2),Nth(i,3),Nth(i,4))   
     trial <- trial + 1
   }

  ################################################
  ##   BLOCK 2:  GOOD VS BAD Words
  ################################################

    SetText(instructBox, "Next, you will do a different categorization task.  This time, you will be asked to categorize two sets of words. " +
                   " Some of the words will describe " + goodWordText + ", while others will describe " + badWordText +". Your goal is to categorize each word as "+
                   " as quickly and accurately as possible.  Like before, if you categorize a word incorrectly, an red X " +
                   " will appear on the screen until you make the correct response. " +
                   " Press the 'X' key to continue.")
    Show(instructBox)
    SetText(gLeftInst, "1:  " + badWordTitle)
    SetText(gRightInst,"2:  " +  goodWordTitle)

    Draw()
    WaitForKeyPress("X")
    Hide(instructBox)
    Draw()

   round <- round + 1


   #In round 1, stimuli should be just the pictures (20 of each)
   stimAll <- Shuffle(Merge(SampleBalanced(goodWordStim,20), SampleBalanced(badWordStim,20)))
   Wait(2500) 
   loop(i,stimAll)
   { 
     FilePrint_(gFileOut, gSubNum + " " + trial + " " +  round + " ")
     MatchTrial(First(i), Nth(i,2),Nth(i,3),Nth(i,4))   
     trial <- trial + 1
   }



  ################################################
  ##   BLOCK 3:  Words and Pictures: Consistent
  ################################################

    SetText(instructBox, "Next, you will categorize both words and pictures in the same block. The responses will be the same" +
                   " as each of the individual trials before, but this time words and pictures will be mixed together." +
                   " Press the 'X' key to continue.")
    Show(instructBox)
    SetText(gLeftInst, "1:   " + badWordTitle + " or " + badPicTitle)
    SetText(gRightInst,"2:   " + goodWordTitle + " or " + goodPicTitle)

 
    Draw()
    WaitForKeyPress("X")
    Hide(instructBox)
    Draw()

   round <- round + 1
 
   #In round 1, stimuli should be just the pictures (20 of each)
   stimAll <- Shuffle(XFlattenN([SampleBalanced(goodWordStim,10), SampleBalanced(badWordStim,10), 
	                            SampleBalanced(goodPicStim,10),  SampleBalanced(badPicStim,10)],1))
   Wait(2500) 
   loop(i,stimAll)
   { 
     FilePrint_(gFileOut, gSubNum + " " + trial + " " + round + " ")
     MatchTrial(First(i), Nth(i,2),Nth(i,3),Nth(i,4))   
     trial <- trial + 1
   }



  ################################################
  ##   BLOCK 4:  Pictures II (same as before)
  ################################################

    SetText(instructBox, "Now, you will perform three more rounds.  In the first round, you will categorize just the pictures again, with " +
                         " the same response mappings as before.  Then, you will categorize words alone, but this time the correct response " +
                         " for good words will be on the left, while bad words will be on the right.  Finally, you will do a mixed categorization " +
                         " block with these two groups together.  " +
                   " Press the 'X' key to continue.")
    Show(instructBox)
    SetText(gLeftInst, "1:  " +  badPicTitle)
    SetText(gRightInst,"2:  " +  goodPicTitle)

    Draw()
    WaitForKeyPress("X")
    Hide(instructBox)
    Draw()

   round <- round + 1
 
   #In round 1, stimuli should be just the pictures (20 of each)
   stimAll <- Shuffle(XFlattenN([SampleBalanced(goodPicStim,20),  SampleBalanced(badPicStim,20)],1))
   Wait(2500) 
   loop(i,stimAll)
   { 
     FilePrint_(gFileOut, gSubNum + " " + trial + " " + round + " ")
     MisMatchTrial(First(i), Nth(i,2),Nth(i,3),Nth(i,4))   
     trial <- trial + 1
   }





  ################################################
  ##   BLOCK 5:  Words II: Inconsistent
  ################################################

    SetText(instructBox, "For this block's categorization, you will categorize words. " +
                         "This time, unlike previous blocks, you should respond '1' (left) for good words and '2' (right) for bad words. " +
                         " Press the 'X' key to continue.")
    Show(instructBox)
    SetText(gLeftInst, "1:  " + goodWordTitle)
    SetText(gRightInst,"2:  " + badWordTitle)

    Draw()
    WaitForKeyPress("X")
    Hide(instructBox)
    Draw()

   round <- round + 1

   #In round 1, stimuli should be just the pictures (20 of each)
   stimAll <- Shuffle(XFlattenN([SampleBalanced(goodWordStim,20), SampleBalanced(badWordStim,20)],1))

   Wait(2500) 
   loop(i,stimAll)
   { 
     FilePrint_(gFileOut, gSubNum + " " + trial + " " + round + " ")
     MisMatchTrial(First(i), Nth(i,2),Nth(i,3),Nth(i,4))   
     trial <- trial + 1
   }





  ################################################
  ##   BLOCK 6:  Words and Pictures: Inconsistent
  ################################################

    SetText(instructBox, "Finally, this block's categorization will combine the previous two blocks.   You will categorize both words and pictures in the same block. " +
                   " you should respond '1' (left) to Good words or pictures of dirty things, and '2' (right) to bad words or pictures of clean things. " +
                   " Press the 'X' key to continue.")
    Show(instructBox)

    SetText(gLeftInst, "1:   " + goodWordTitle + " or " + badPicTitle)
    SetText(gRightInst,"2:   " + badWordTitle + " or " + goodPicTitle)

    Draw()
    WaitForKeyPress("X")
    Hide(instructBox)
    Draw()

   round <- round + 1

   #In round 1, stimuli should be just the pictures (20 of each)
   stimAll <- Shuffle(XFlattenN([SampleBalanced(goodWordStim,10), SampleBalanced(badWordStim,10), 
	                            SampleBalanced(goodPicStim,10),  SampleBalanced(badPicStim,10)],1))
   Wait(2500) 
   loop(i,stimAll)
   { 
     FilePrint_(gFileOut, gSubNum + " " + trial + " " + round + " ")
     MisMatchTrial(First(i), Nth(i,2),Nth(i,3),Nth(i,4))   
     trial <- trial + 1
   }




  ################################################
  ##   Debriefing
  ################################################

    SetText(instructBox, "Debriefing goes here." +
                   " Press the 'X' key to finish")
    Show(instructBox)
    Draw()
    WaitForKeyPress("X")
    Hide(instructBox)
    Draw()
    FileClose(gFileOut)

}


define MatchTrial(stim, text, type, lgoodness)
{

	AddObject(stim,gWin)
    Move(stim, 500,500)
    Show(stim)
    Draw(gWin)
    t1 <- GetTime()

	response <-  WaitForListKeyPress(["1","2"])
    t2 <- GetTime()
 
   # Now, the response needs to match the appropriate type/goodness
   # For this condition, since they match, the goodness determines the response.

   corrResp <- 3-ToNumber(lgoodness)
   if(ToNumber(response) == corrResp)
   {
      corr <- 1
   } else {
      corr <- 0
      AddObject(gCorrection, gWin)
      Move(gCorrection, 500,100)
      Show(gCorrection)
      Draw()


      WaitForKeyPress(corrResp + "")
      Hide(gCorrection)
      RemoveObject(gCorrection,gWin)
   }
   FilePrint(gFileOut, FixString(text) + " " + type + " " + lgoodness + " " + (t2-t1) + " " + corr )

   Hide(stim)
   Draw(gWin)
   RemoveObject(stim,gWin)
}



define MisMatchTrial(stim, text, type, lgoodness)
{

   
	AddObject(stim,gWin)
    Move(stim, 500,500)
    Show(stim)
    Draw(gWin)
    t1 <- GetTime()

	response <-  WaitForListKeyPress(["1","2"])
    t2 <- GetTime()
 


   #Since there is a mismatch, the correct response depends on both the type and the 'goodness'
   if(type != lgoodness)
   {
       corrResp <- 1
   } else {
       corrResp <- 2
   }
  

   if(ToNumber(response) == corrResp)
   {
      corr <- 1
   } else {
      corr <- 0
      AddObject(gCorrection, gWin)
      Move(gCorrection, 500,100)
      Show(gCorrection)
      Draw()


      WaitForKeyPress(corrResp + "")
      Hide(gCorrection)
      RemoveObject(gCorrection,gWin)
   }
   FilePrint(gFileOut,FixString(text) + " " + type + " " + lgoodness + " " + (t2-t1) + " " + corr)

   Hide(stim)
   Draw(gWin)
   RemoveObject(stim,gWin)
}




##This flattens a nested list into a single list.
define XFlatten(list)
{
        if(not IsList(list))
        {
          SignalFatalError("First Argument of Flatten(<list>) must be a list.")
        }

        newlist <- []

        loop(i,list)
        {
          if(IsList(i))
      {
                  newlist <- Merge(newlist, XFlatten(i))

      } else {
             newlist <- Append(newlist,i)
      }

        }

  return newlist
}



define XFlattenN(list, n)
{

        if(not IsList(list))
        {
          SignalFatalError("First Argument of FlattenN(<list>) must be a list.")

        }

        if(not IsInteger(n))
        {
          SignalFatalError("Second Argument of FlattenN(<list>) must be an integer.")
        }


        newlist <- []
        loop(i,list)
        {
          if(IsList(i) and n > 0)
      {
                  newlist <- Merge(newlist, XFlattenN(i, n-1))

      } else {
             newlist <- Append(newlist,i)
      }

        }

  return newlist
}

## This changes a string with spaces to a string without spaces, but with underscores.
##
define FixString(wordwithspaces)
{

   list <- SplitString(wordwithspaces, " ")
   
   newString <- ""
   index <- 0
   loop(i,list)
   {
     if(index == 0)
     {
       newString <- newString + i
     } else {
       newString <- newString + "_" + i
     }
      index <- index + 1
   }
	return newString
}




## This is like SampleWithReplacement, but it makes sure that each item is sampled roughly 
## equally. First, the list is shuffled, then repeated so that it is longer than the number you need.  
## Then, it is truncated to be the right number.  Finally, it is shuffled again.  This ensures that
## each item will be sampled a roughly equal number of times. (+/-1)
define SampleBalanced(list, number)
{
  ## Randomize
  randlist <- Shuffle(list)

  ## Get repeated list (too long)
  listlength <- Length(randlist)
  multiply <- Ceiling(number / listlength)
  fullStim <- RepeatList(randlist, multiply)
  
  newStim <- SubList(fullStim,1,number)
  
  return Shuffle(newStim)
}